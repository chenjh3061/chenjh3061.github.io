<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>joho world</title>
  
  <subtitle>Welcome!</subtitle>
  <link href="https://chenjh3061/personalWeb.github.io/atom.xml" rel="self"/>
  
  <link href="https://chenjh3061/personalWeb.github.io/"/>
  <updated>2024-06-11T08:38:18.293Z</updated>
  <id>https://chenjh3061/personalWeb.github.io/</id>
  
  <author>
    <name>Joho Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构（二）——栈、队列</title>
    <link href="https://chenjh3061/personalWeb.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <id>https://chenjh3061/personalWeb.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</id>
    <published>2024-06-11T08:37:11.000Z</published>
    <updated>2024-06-11T08:38:18.293Z</updated>
    
    
    <summary type="html">学习记录</summary>
    
    
    
    <category term="学习笔记" scheme="https://chenjh3061/personalWeb.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://chenjh3061/personalWeb.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://chenjh3061/personalWeb.github.io/%E9%9A%8F%E7%AC%94/"/>
    <id>https://chenjh3061/personalWeb.github.io/%E9%9A%8F%E7%AC%94/</id>
    <published>2024-06-11T01:24:45.240Z</published>
    <updated>2024-06-11T01:24:51.245Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Obsidian用法</title>
    <link href="https://chenjh3061/personalWeb.github.io/Obsidian%E7%94%A8%E6%B3%95/"/>
    <id>https://chenjh3061/personalWeb.github.io/Obsidian%E7%94%A8%E6%B3%95/</id>
    <published>2024-06-10T15:41:45.379Z</published>
    <updated>2024-07-05T07:31:56.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="双链"><a href="#双链" class="headerlink" title="双链"></a>双链</h1><p>用[[]]可以链接到别的笔记，加井号选择段落，再加^选择每一段内容，自己在要连接的文章里打上^可以自己做标记。<br>加 | 改别名，前面加 ！可以展开被引用的内容。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;双链&quot;&gt;&lt;a href=&quot;#双链&quot; class=&quot;headerlink&quot; title=&quot;双链&quot;&gt;&lt;/a&gt;双链&lt;/h1&gt;&lt;p&gt;用[[]]可以链接到别的笔记，加井号选择段落，再加^选择每一段内容，自己在要连接的文章里打上^可以自己做标记。&lt;br&gt;加 |</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>好玩代码收集</title>
    <link href="https://chenjh3061/personalWeb.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%89%B9%E6%AE%8A%E8%AE%B0%E5%BD%95/%E5%A5%BD%E7%8E%A9%E4%BB%A3%E7%A0%81%E6%94%B6%E9%9B%86/"/>
    <id>https://chenjh3061/personalWeb.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%89%B9%E6%AE%8A%E8%AE%B0%E5%BD%95/%E5%A5%BD%E7%8E%A9%E4%BB%A3%E7%A0%81%E6%94%B6%E9%9B%86/</id>
    <published>2024-06-09T13:29:11.000Z</published>
    <updated>2024-06-15T15:32:09.953Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS身份证格式校验"><a href="#JS身份证格式校验" class="headerlink" title="JS身份证格式校验"></a>JS身份证格式校验</h1><p><a href="https://mp.weixin.qq.com/s/V0Fquj_Dy6OpqbwqMHUg6Q">https://mp.weixin.qq.com/s/V0Fquj_Dy6OpqbwqMHUg6Q</a></p><h1 id="检测并显示密码强度"><a href="#检测并显示密码强度" class="headerlink" title="检测并显示密码强度"></a>检测并显示密码强度</h1><p><a href="https://mp.weixin.qq.com/s/DCS4RKrXuPFj8sOoMzVY-g">https://mp.weixin.qq.com/s/DCS4RKrXuPFj8sOoMzVY-g</a></p><h1 id="画一棵随机树"><a href="#画一棵随机树" class="headerlink" title="画一棵随机树"></a>画一棵随机树</h1><p><a href="https://mp.weixin.qq.com/s/6jfubgtHJly56w21j_mlQw">https://mp.weixin.qq.com/s/6jfubgtHJly56w21j_mlQw</a></p><h1 id="7个一行JS"><a href="#7个一行JS" class="headerlink" title="7个一行JS"></a>7个一行JS</h1><p><a href="https://mp.weixin.qq.com/s/YjX5D4EtPzr_5Z4rTBkTaw">https://mp.weixin.qq.com/s/YjX5D4EtPzr_5Z4rTBkTaw</a></p>]]></content>
    
    
    <summary type="html">一些好玩代码收集</summary>
    
    
    
    <category term="杂七杂八" scheme="https://chenjh3061/personalWeb.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
    <category term="代码收集" scheme="https://chenjh3061/personalWeb.github.io/tags/%E4%BB%A3%E7%A0%81%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>面试题目记录</title>
    <link href="https://chenjh3061/personalWeb.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%89%B9%E6%AE%8A%E8%AE%B0%E5%BD%95/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <id>https://chenjh3061/personalWeb.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%89%B9%E6%AE%8A%E8%AE%B0%E5%BD%95/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/</id>
    <published>2024-06-05T09:34:11.000Z</published>
    <updated>2024-06-21T12:53:34.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2024-06-06深圳学而思小高科学素养秋招提前批"><a href="#2024-06-06深圳学而思小高科学素养秋招提前批" class="headerlink" title="2024-06-06深圳学而思小高科学素养秋招提前批"></a>2024-06-06深圳学而思小高科学素养秋招提前批</h1><p>试讲科学思维10min+聊天20min<br>有没什么考公考研打算、</p><p>![[Pasted image 20240607110710.png]]</p><h1 id="2024腾讯CSIG技术产品商务培训生-实习"><a href="#2024腾讯CSIG技术产品商务培训生-实习" class="headerlink" title="2024腾讯CSIG技术产品商务培训生(实习)"></a>2024腾讯CSIG技术产品商务培训生(实习)</h1><p>2024-06-21 集体面试</p><p>同学们都好强啊</p><p>2024-06</p>]]></content>
    
    
    <summary type="html">参加的面试集锦</summary>
    
    
    
    <category term="笔面记录" scheme="https://chenjh3061/personalWeb.github.io/categories/%E7%AC%94%E9%9D%A2%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="面经" scheme="https://chenjh3061/personalWeb.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>笔试题目记录</title>
    <link href="https://chenjh3061/personalWeb.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%89%B9%E6%AE%8A%E8%AE%B0%E5%BD%95/%E7%AC%94%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    <id>https://chenjh3061/personalWeb.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%89%B9%E6%AE%8A%E8%AE%B0%E5%BD%95/%E7%AC%94%E8%AF%95%E9%A2%98%E7%9B%AE/</id>
    <published>2024-05-28T14:29:50.000Z</published>
    <updated>2024-07-05T07:19:38.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2024-5-28-深圳同行者Web前端实习"><a href="#2024-5-28-深圳同行者Web前端实习" class="headerlink" title="2024-5-28 深圳同行者Web前端实习"></a>2024-5-28 深圳同行者Web前端实习</h1><p>1、写一个函数，输入为一个数组，输出一个包含它所有子集的数组。<br>        <a href="https://leetcode.cn/problems/TVdhkn/">力扣LCR079.子集</a><br>    子集问题，可以用迭代法或者递归。迭代法中，假设数组有三个元素，子集就可以看做从000~111的二进制位变化，也就可以依此设置一个mask，通过mask的变换添加子集。<br>      递归法就用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代，O(n*2^)</span></span><br><span class="line"><span class="keyword">var</span> subsets = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line"><span class="keyword">const</span> ans = [];</span><br><span class="line"><span class="keyword">const</span> n = nums.<span class="property">length</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> mask=<span class="number">0</span>;mask&lt; (<span class="number">1</span>&lt;&lt;n);mask++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(mask &amp; (<span class="number">1</span>&lt;&lt;i))&#123;</span><br><span class="line">t.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans.<span class="title function_">push</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------</span><br><span class="line"><span class="comment">//递归，O(n*2^)</span></span><br><span class="line"><span class="keyword">var</span> subsets = <span class="keyword">function</span>(<span class="params">nums</span>) &#123; </span><br><span class="line"><span class="keyword">const</span> t = []; </span><br><span class="line"><span class="keyword">const</span> ans = []; </span><br><span class="line"><span class="keyword">const</span> n = nums.<span class="property">length</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">cur</span>) =&gt; &#123; </span><br><span class="line"><span class="keyword">if</span> (cur === nums.<span class="property">length</span>) &#123; </span><br><span class="line">ans.<span class="title function_">push</span>(t.<span class="title function_">slice</span>()); </span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line">&#125; </span><br><span class="line">t.<span class="title function_">push</span>(nums[cur]); </span><br><span class="line"><span class="title function_">dfs</span>(cur + <span class="number">1</span>, nums); </span><br><span class="line">t.<span class="title function_">pop</span>(t.<span class="property">length</span> - <span class="number">1</span>); </span><br><span class="line"><span class="title function_">dfs</span>(cur + <span class="number">1</span>, nums); </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">dfs</span>(<span class="number">0</span>, nums); </span><br><span class="line"><span class="keyword">return</span> ans; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>2、不使用split方法，实现两个函数：<br>    (1)输入字符串str和分隔符spl，输出被分割后的字符串数组。例：输入abc&amp;&amp;de和&amp;&amp;，输出[“abc”,”de”]。<br>    (2)输入字符串数组str和分隔符spl，输出合并后的字符串。例：输入[“abc”,”de”]和&amp;&amp;，输出abc&amp;&amp;de。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分割</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">customSplit</span>(<span class="params">str, spl</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> current = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; str.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.<span class="title function_">substring</span>(i, i + spl.<span class="property">length</span>) === spl) &#123;</span><br><span class="line">            result.<span class="title function_">push</span>(current);</span><br><span class="line">            current = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            i += spl.<span class="property">length</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current += str[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    result.<span class="title function_">push</span>(current); <span class="comment">// 添加最后一个部分</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;abc&amp;&amp;de&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> spl = <span class="string">&quot;&amp;&amp;&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">customSplit</span>(str, spl)); <span class="comment">// 输出 [&quot;abc&quot;, &quot;de&quot;]</span></span><br><span class="line">---------------------------------------------------------</span><br><span class="line"><span class="comment">//合并</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">customJoin</span>(<span class="params">arr, spl</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        result += arr[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; arr.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">            result += spl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;de&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> spl = <span class="string">&quot;&amp;&amp;&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">customJoin</span>(arr, spl)); <span class="comment">// 输出 &quot;abc&amp;&amp;de&quot;</span></span><br></pre></td></tr></table></figure><p>3、找出不大于n的最大质数<br>        [力扣204计数质数][anchor-3]<br>    其实只要想起来怎么找质数就行，两种方法，枚举和埃氏筛。枚举记得加上一个平方加速运算，埃氏筛记得原理是创一个数组，从小开始遍历到n，把遍历到的数的所有倍数都标记为0，剩下的全都是1~n的质数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//枚举，O(n√n)</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isPrime</span> = (<span class="params">x</span>) =&gt; &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>; i*i&lt;=x; ++i)&#123;</span><br><span class="line"><span class="keyword">if</span>( x%i == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ture;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------</span><br><span class="line"><span class="comment">//埃氏筛，O(nloglogn)</span></span><br><span class="line"><span class="keyword">var</span> countPrimes = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> isPrime = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">    isPrime[<span class="number">0</span>] = isPrime[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i*i; j&lt;=n; j+=i)&#123;<span class="comment">//精髓在这里</span></span><br><span class="line">            isPrime[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=n-<span class="number">1</span>;i&gt;<span class="number">0</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isPrime[i])&#123;</span><br><span class="line">            ans = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>4、数组中共有一千个数，数的范围在[0,999]，有且只有两个相同的数，找出这个数。<br>    map or set</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">findDuplicate</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> hashMap = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hashMap[arr[i]] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hashMap[arr[i]] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 如果没有找到重复的数字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [...<span class="title class_">Array</span>(<span class="number">999</span>).<span class="title function_">keys</span>(), <span class="number">500</span>]; <span class="comment">// 示例数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">findDuplicate</span>(arr));</span><br><span class="line">---------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findDuplicate</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.<span class="title function_">has</span>(arr[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        set.<span class="title function_">add</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 如果没有找到重复的数字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [...<span class="title class_">Array</span>(<span class="number">999</span>).<span class="title function_">keys</span>(), <span class="number">500</span>]; <span class="comment">// 示例数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">findDuplicate</span>(arr));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5、n个人(编号1~n)围成一个圈报数，从1报数到m，报到m的人出列，下一个人重新从1开始报数，求最后一个留下的人的编号。<br>    [约瑟夫环问题][anchor-5]，模拟单链表、数学递推、公式法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环链表</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createList</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="comment">//链表节点的数据结构</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">createNode</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">value</span>: value,</span><br><span class="line">            <span class="attr">next</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//链表头节点</span></span><br><span class="line">    <span class="keyword">let</span> head = <span class="title function_">createNode</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> node = head;</span><br><span class="line">    <span class="comment">//自头节点之后创建节点之间的关联关系</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= num; i++) &#123;</span><br><span class="line">        node.<span class="property">next</span> = <span class="title function_">createNode</span>(i);</span><br><span class="line">        node = node.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后一个节点指向头节点，构成循环链表</span></span><br><span class="line">    node.<span class="property">next</span> = head;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deleteListNode</span>(<span class="params">num, nth</span>) &#123;</span><br><span class="line">    <span class="comment">//创建数据长度为num的循环链表</span></span><br><span class="line">    <span class="keyword">let</span> node = <span class="title function_">createList</span>(num);</span><br><span class="line">    <span class="comment">//链表长度&gt;1时，继续下一轮</span></span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= nth - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == nth - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//i为nth-1，则node.next即为第nth个节点。剔除node.next</span></span><br><span class="line">                node.<span class="property">next</span> = node.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">                <span class="comment">//链表长度--</span></span><br><span class="line">                num--;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//剩余的最后一个节点的value值即为最后一人编号</span></span><br><span class="line">    <span class="keyword">return</span> node.<span class="property">value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//deleteListNode(m,n)即可得到最终结果</span></span><br><span class="line">---------------------------------------------------------</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Josephus</span>(<span class="params">num,nth</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="title class_">Josephus</span>(num-<span class="number">1</span>,nth)+nth)%num</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Josephus(N,M)+1即为最终编号</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="2024-6-4深圳学而思小高科学素养教师秋招提前批"><a href="#2024-6-4深圳学而思小高科学素养教师秋招提前批" class="headerlink" title="2024-6-4深圳学而思小高科学素养教师秋招提前批"></a>2024-6-4深圳学而思小高科学素养教师秋招提前批</h1><p>纯MBTI</p><h1 id="2024-6-5深圳腾讯音乐娱乐IOS客户端实习"><a href="#2024-6-5深圳腾讯音乐娱乐IOS客户端实习" class="headerlink" title="2024-6-5深圳腾讯音乐娱乐IOS客户端实习"></a>2024-6-5深圳腾讯音乐娱乐IOS客户端实习</h1><h3 id="一、编程题"><a href="#一、编程题" class="headerlink" title="一、编程题"></a>一、编程题</h3><h4 id="1、-删除升序数组重复元素-："><a href="#1、-删除升序数组重复元素-：" class="headerlink" title="1、[删除升序数组重复元素]："></a>1、[删除升序数组重复元素]：</h4><pre><code>~给一个长度为n的升序数组nums，删除一部分重复元素（需原地改变数组），让这个数组每个数字都严格大于前一个数（第一个数除外），返回删除后的数组长度，被操作过的数组前若干个数要严格单增。</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双指针，妙解法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> uniqueIndex = <span class="number">1</span>; <span class="comment">// 从第二个元素开始检查</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] !== nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            nums[uniqueIndex] = nums[i];</span><br><span class="line">            uniqueIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uniqueIndex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> newLength = <span class="title function_">removeDuplicates</span>(nums);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newLength); <span class="comment">// 输出新的数组长度</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nums.<span class="title function_">slice</span>(<span class="number">0</span>, newLength)); <span class="comment">// 输出新的数组内容</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2、-螺旋矩阵"><a href="#2、-螺旋矩阵" class="headerlink" title="2、[螺旋矩阵]"></a>2、[螺旋矩阵]</h4><p>背代码！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> generateMatrix = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> startX = startY = <span class="number">0</span>;   <span class="comment">// 起始位置</span></span><br><span class="line">    <span class="keyword">let</span> loop = <span class="title class_">Math</span>.<span class="title function_">floor</span>(n/<span class="number">2</span>);   <span class="comment">// 旋转圈数</span></span><br><span class="line">    <span class="keyword">let</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>(n/<span class="number">2</span>);    <span class="comment">// 中间位置</span></span><br><span class="line">    <span class="keyword">let</span> offset = <span class="number">1</span>;    <span class="comment">// 控制每一层填充元素个数</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">1</span>;     <span class="comment">// 更新填充数字</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (loop--) &#123;</span><br><span class="line">        <span class="keyword">let</span> row = startX, col = startY;</span><br><span class="line">        <span class="comment">// 上行从左到右（左闭右开）</span></span><br><span class="line">        <span class="keyword">for</span> (; col &lt; n - offset; col++) &#123;</span><br><span class="line">            res[row][col] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右列从上到下（左闭右开）</span></span><br><span class="line">        <span class="keyword">for</span> (; row &lt; n - offset; row++) &#123;</span><br><span class="line">            res[row][col] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下行从右到左（左闭右开）</span></span><br><span class="line">        <span class="keyword">for</span> (; col &gt; startY; col--) &#123;</span><br><span class="line">            res[row][col] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左列做下到上（左闭右开）</span></span><br><span class="line">        <span class="keyword">for</span> (; row &gt; startX; row--) &#123;</span><br><span class="line">            res[row][col] = count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新起始位置</span></span><br><span class="line">        startX++;</span><br><span class="line">        startY++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新offset</span></span><br><span class="line">        offset += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span></span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        res[mid][mid] = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3、括号区间匹配"><a href="#3、括号区间匹配" class="headerlink" title="3、括号区间匹配"></a>3、括号区间匹配</h4><pre><code>由[]、()组成的字符串，最少插入多少个括号可以实现匹配？输出所需的括号数量。</code></pre><p>就是注意考虑情况，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minInsertionsToMatch = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> leftNeeded = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> rightNeeded = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (char === <span class="string">&#x27;(&#x27;</span> || char === <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            rightNeeded++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (char === <span class="string">&#x27;)&#x27;</span> || char === <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rightNeeded &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                rightNeeded--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                leftNeeded++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> leftNeeded + rightNeeded;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;([)]&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">&quot;(([]&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">minInsertionsToMatch</span>(s1)); <span class="comment">// 输出: 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">minInsertionsToMatch</span>(s2)); <span class="comment">// 输出: 2</span></span><br></pre></td></tr></table></figure><h3 id="二、问答题"><a href="#二、问答题" class="headerlink" title="二、问答题"></a>二、问答题</h3><h4 id="1、进程和线程有什么区别？进程间通信方式有哪些？"><a href="#1、进程和线程有什么区别？进程间通信方式有哪些？" class="headerlink" title="1、进程和线程有什么区别？进程间通信方式有哪些？"></a>1、进程和线程有什么区别？进程间通信方式有哪些？</h4><h4 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h4><ul><li><strong>进程</strong>：<ul><li>是程序的一次执行过程，操作系统进行资源分配和调度执行的基本单位，拥有独立的内存空间。</li><li>进程之间的资源是隔离的，进程切换开销较大。</li><li>适用于需要并行处理且相互隔离的任务。</li></ul></li><li><strong>线程</strong>：<ul><li>是进程中的一个执行单元，程序执行的最小单位。共享进程的内存空间和资源。</li><li>线程之间通信方便，但缺乏进程间的隔离性，线程切换开销较小。</li><li>适用于需要并发处理且共享数据的任务。</li></ul></li></ul><h4 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h4><ul><li>**管道 (Pipe)**：用于父子进程间的通信，单向或双向的字节流。</li><li>**消息队列 (Message Queue)**：由消息组成的链表，存储在内核中。</li><li>**共享内存 (Shared Memory)**：多个进程共享一块内存区域，速度快，但需要同步机制。</li><li>**信号 (Signal)**：用于通知进程某个事件的发生。</li><li>**套接字 (Socket)**：用于不同主机或同一主机上进程间的网络通信。</li><li>**信号量 (Semaphore)**：用于进程间的同步控制。</li></ul><h4 id="2、列举常用数据结构，各自的特点和使用场景"><a href="#2、列举常用数据结构，各自的特点和使用场景" class="headerlink" title="2、列举常用数据结构，各自的特点和使用场景"></a>2、列举常用数据结构，各自的特点和使用场景</h4><ul><li>**数组 (Array)**：连续内存空间，随机访问快，插入和删除慢。适用于需要频繁访问的场景。</li><li>**链表 (Linked List)**：非连续内存空间，插入和删除快，随机访问慢。适用于需要频繁插入和删除的场景。</li><li>**栈 (Stack)**：后进先出 (LIFO)，适用于递归、表达式求值、语法分析等场景。</li><li>**队列 (Queue)**：先进先出 (FIFO)，适用于排队处理、广度优先搜索等场景。</li><li>**哈希表 (Hash Table)**：通过哈希函数进行快速查找，适用于需要快速查找和插入的场景。</li><li>**树 (Tree)**：层次结构，适用于需要快速查找、插入和删除的场景，如二叉搜索树、平衡树。</li><li>**图 (Graph)**：用于表示网络结构，适用于图论算法，如最短路径、最小生成树等。</li><li>**堆 (Heap)**：完全二叉树，常用于实现优先队列。</li></ul><h4 id="3、多线程编程要注意哪些情况？"><a href="#3、多线程编程要注意哪些情况？" class="headerlink" title="3、多线程编程要注意哪些情况？"></a>3、多线程编程要注意哪些情况？</h4><ul><li><strong>线程安全</strong>：避免多个线程同时访问共享资源，使用锁或同步机制。</li><li><strong>死锁</strong>：多个线程互相等待对方释放资源，导致程序无法继续运行。</li><li><strong>资源竞争</strong>：多个线程争夺同一资源，导致数据不一致或程序崩溃。</li><li><strong>线程调度</strong>：合理调度线程，避免过多线程导致的上下文切换开销。</li><li><strong>内存一致性</strong>：保证线程之间的内存可见性，使用内存屏障或锁机制。</li></ul><h4 id="4、HTTP请求头包含哪些内容？"><a href="#4、HTTP请求头包含哪些内容？" class="headerlink" title="4、HTTP请求头包含哪些内容？"></a>4、HTTP请求头包含哪些内容？</h4><ul><li>**通用头部 (General Headers)**：如 <code>Cache-Control</code>, <code>Connection</code>, <code>Date</code>。</li><li>**请求头部 (Request Headers)**：如 <code>Accept</code>, <code>Accept-Encoding</code>, <code>Authorization</code>, <code>Host</code>, <code>User-Agent</code>, <code>Referer</code>。</li><li>**响应头部 (Response Headers)**：如 <code>Location</code>, <code>Server</code>, <code>Set-Cookie</code>, <code>Content-Type</code>。</li><li>**实体头部 (Entity Headers)**：如 <code>Content-Length</code>, <code>Content-Encoding</code>, <code>Content-Language</code>, <code>Content-Location</code>, <code>Content-MD5</code>, <code>Last-Modified</code>。</li></ul><h4 id="5、TCP和HTTP的具体区别？"><a href="#5、TCP和HTTP的具体区别？" class="headerlink" title="5、TCP和HTTP的具体区别？"></a>5、TCP和HTTP的具体区别？</h4><ul><li><p>**TCP (Transmission Control Protocol)**：</p><ul><li>是传输层协议，提供可靠的、面向连接的通信。</li><li>确保数据包按序到达，进行错误检查和流量控制。</li><li>用于底层数据传输，如 HTTP 协议的数据传输。</li></ul></li><li><p>**HTTP (HyperText Transfer Protocol)**：</p><ul><li>是应用层协议，基于 TCP 协议。</li><li>无状态协议，每个请求&#x2F;响应都是独立的。</li><li>用于在客户端和服务器之间传输超文本（如 HTML 文档、图片、视频）。</li></ul></li></ul><h4 id="6、怎么提升在线视频的播放秒开率？"><a href="#6、怎么提升在线视频的播放秒开率？" class="headerlink" title="6、怎么提升在线视频的播放秒开率？"></a>6、怎么提升在线视频的播放秒开率？</h4><ul><li><strong>优化缓冲策略</strong>：减少初始缓冲时间，根据网络情况调整缓冲区大小。</li><li><strong>预加载技术</strong>：在用户点击播放前预加载部分视频内容。</li><li><strong>分段加载</strong>：将视频分成多个小段，先加载前几段。</li><li>**使用内容分发网络 (CDN)**：将视频内容分发到离用户最近的服务器，减少传输延迟。</li><li><strong>压缩视频</strong>：使用更高效的视频编码格式，减少视频文件大小。</li><li><strong>网络协议优化</strong>：使用更高效的传输协议，如 HTTP&#x2F;2 或 QUIC。</li><li><strong>客户端优化</strong>：优化播放器的解码和渲染性能。</li></ul><h1 id="2024-06-06用友提前批模拟笔试"><a href="#2024-06-06用友提前批模拟笔试" class="headerlink" title="2024-06-06用友提前批模拟笔试"></a>2024-06-06用友提前批模拟笔试</h1><p>1、大数减法：以字符串的形式读入两个数字，编写一个函数计算它们的差，以字符串形式返回。</p><h6 id="输入示例"><a href="#输入示例" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2</span><br></pre></td></tr></table></figure><h6 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><p>解法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">subtractStrings</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    <span class="comment">// 确定结果的符号</span></span><br><span class="line">    <span class="keyword">let</span> isNegative = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (num1 === num2) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (num1.<span class="property">length</span> &lt; num2.<span class="property">length</span> || (num1.<span class="property">length</span> === num2.<span class="property">length</span> &amp;&amp; num1 &lt; num2)) &#123;</span><br><span class="line">        [num1, num2] = [num2, num1];</span><br><span class="line">        isNegative = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 补齐 num2 前导零</span></span><br><span class="line">    num2 = num2.<span class="title function_">padStart</span>(num1.<span class="property">length</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> borrow = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = num1.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">let</span> digit1 = <span class="built_in">parseInt</span>(num1[i], <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">let</span> digit2 = <span class="built_in">parseInt</span>(num2[i], <span class="number">10</span>) + borrow;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (digit1 &lt; digit2) &#123;</span><br><span class="line">            digit1 += <span class="number">10</span>;</span><br><span class="line">            borrow = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            borrow = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result.<span class="title function_">push</span>(digit1 - digit2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除结果中的前导零</span></span><br><span class="line">    <span class="keyword">while</span> (result[result.<span class="property">length</span> - <span class="number">1</span>] === <span class="number">0</span>) &#123;</span><br><span class="line">        result.<span class="title function_">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理负号</span></span><br><span class="line">    <span class="keyword">if</span> (isNegative) &#123;</span><br><span class="line">        result.<span class="title function_">push</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取输入</span></span><br><span class="line"><span class="keyword">const</span> readline = <span class="built_in">require</span>(<span class="string">&#x27;readline&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rl = readline.<span class="title function_">createInterface</span>(&#123;</span><br><span class="line">    <span class="attr">input</span>: process.<span class="property">stdin</span>,</span><br><span class="line">    <span class="attr">output</span>: process.<span class="property">stdout</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rl.<span class="title function_">on</span>(<span class="string">&#x27;line&#x27;</span>, <span class="function">(<span class="params">input</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [num1, num2] = input.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">subtractStrings</span>(num1, num2));</span><br><span class="line">    rl.<span class="title function_">close</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、滑动窗口最大值<br>给定一个整数数组 nums 和一个整数 k，k 表示滑动窗口的大小。你需要找出每个滑动窗口中的最大值与最小值的差，并返回这些差的最大值。</p><h6 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h6><p>数组的长度为 n，1 &lt;&#x3D; n &lt;&#x3D; 10000，数组中的每个元素范围为[-10000,10000]，滑动窗口大小k的范围为[1,n]。</p><h6 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h6><p>例如，给你nums &#x3D; [1,3,-1,-3,5,3,6,7]和 k &#x3D; 3，每个窗口中的最大值与最小值的差分别为[2,4,6,8]，所以返回 8。</p><h6 id="输入示例-1"><a href="#输入示例-1" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br></pre></td></tr></table></figure><h6 id="输出示例-1"><a href="#输出示例-1" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><p>3、软件构建<br>某个大型软件项目的构建系统拥有 N 个文件，文件编号从 0 到 N - 1，在这些文件中，某些文件依赖于其他文件的内容，这意味着如果文件 A 依赖于文件 B，则必须在处理文件 A 之前处理文件 B （0 &lt;&#x3D; A, B &lt;&#x3D; N - 1）。请编写一个算法，用于确定文件处理的顺序。</p><h6 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行输入两个正整数 N, M。表示 N 个文件之间拥有 M 条依赖关系。后续 M 行，每行两个正整数 S 和 T，表示 T 文件依赖于 S 文件。</p><h6 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出共一行，如果能处理成功，则输出文件顺序，用空格隔开。 <br>如果不能成功处理（相互依赖），则输出 -1。</p><h6 id="输入示例-2"><a href="#输入示例-2" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5 4</span><br><span class="line">0 1</span><br><span class="line">0 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure><h6 id="输出示例-2"><a href="#输出示例-2" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4</span><br></pre></td></tr></table></figure><h1 id="2024-06-13美团模拟笔试"><a href="#2024-06-13美团模拟笔试" class="headerlink" title="2024-06-13美团模拟笔试"></a>2024-06-13美团模拟笔试</h1><h3 id="1、小美的排列询问"><a href="#1、小美的排列询问" class="headerlink" title="1、小美的排列询问"></a>1、小美的排列询问</h3><h6 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h6><p>小美拿到了一个排列。她想知道在这个排列中，x 和 y 是否是相邻的。你能帮帮她吗？排列是指一个长度为 n 的数组，其中 1 到 n 每个元素恰好出现一次。</p><h6 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行输入一个正整数 n（1 &lt;&#x3D; n &lt;&#x3D; 200000），代表排列的长度。 <br>第二行输入 n 个正整数 ai，代表排列的元素。 <br>第三行输入两个正整数 x 和 y（1 &lt;&#x3D; ai, x, y &lt;&#x3D; n），用空格隔开。<br>保证 x !&#x3D; y</p><h6 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述"></a>输出描述</h6><p>如果 x 和 y 是相邻的，输出 Yes；否则输出 No。</p><h6 id="输入示例-3"><a href="#输入示例-3" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 4 2 3</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure><h6 id="输出示例-3"><a href="#输出示例-3" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h6 id="提示信息"><a href="#提示信息" class="headerlink" title="提示信息"></a>提示信息</h6><p>输入的排列是 1 4 2 3，x &#x3D; 2，y &#x3D; 4，2 和 4 是相邻的。输出 YES.</p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This function will be used to read input from the console</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">readInput</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> readline = <span class="built_in">require</span>(<span class="string">&#x27;readline&#x27;</span>);</span><br><span class="line">        <span class="keyword">const</span> rl = readline.<span class="title function_">createInterface</span>(&#123;</span><br><span class="line">            <span class="attr">input</span>: process.<span class="property">stdin</span>,</span><br><span class="line">            <span class="attr">output</span>: process.<span class="property">stdout</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> input = [];</span><br><span class="line">        rl.<span class="title function_">on</span>(<span class="string">&#x27;line&#x27;</span>, <span class="function">(<span class="params">line</span>) =&gt;</span> &#123;</span><br><span class="line">            input.<span class="title function_">push</span>(line);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        rl.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(input);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is the main function to process the input and solve the problem</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> input = <span class="keyword">await</span> <span class="title function_">readInput</span>();</span><br><span class="line">    <span class="keyword">const</span> n = <span class="built_in">parseInt</span>(input[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">const</span> permutation = input[<span class="number">1</span>].<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">map</span>(<span class="title class_">Number</span>);</span><br><span class="line">    <span class="keyword">const</span> [x, y] = input[<span class="number">2</span>].<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">map</span>(<span class="title class_">Number</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Function to check if x and y are adjacent</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">areAdjacent</span>(<span class="params">n, permutation, x, y</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((permutation[i] === x &amp;&amp; permutation[i + <span class="number">1</span>] === y) || (permutation[i] === y &amp;&amp; permutation[i + <span class="number">1</span>] === x)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> adjacent = <span class="title function_">areAdjacent</span>(n, permutation, x, y);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(adjacent ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call the main function</span></span><br><span class="line"><span class="title function_">main</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2、小美走公路"><a href="#2、小美走公路" class="headerlink" title="2、小美走公路"></a>2、小美走公路</h3><h6 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h6><p>有一个环形的公路，上面共有 n 站，现在给定了顺时针第 i 站到第 i + 1 站之间的距离（特殊的，也给出了第 n 站到第 1 站的距离）。小美想沿着公路第 x 站走到第 y 站，她想知道最短的距离是多少？</p><h6 id="输入描述-3"><a href="#输入描述-3" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行输入一个正整数 n（1 &lt;&#x3D; n &lt;&#x3D; 10^5），代表站的数量。 <br>第二行输入 n 个正整数 ai（1 &lt;&#x3D; ai &lt;&#x3D; 10^9），前 n - 1 个数代表顺时针沿着公路走，i 站到第 i + 1 站之间的距离；最后一个正整数代表顺时针沿着公路走，第 n 站到第 1 站的距离。· 第三行输入两个正整数 x 和 y（1 &lt;&#x3D; x, y &lt;&#x3D; n），代表小美的出发地和目的地。</p><h6 id="输出描述-3"><a href="#输出描述-3" class="headerlink" title="输出描述"></a>输出描述</h6><p>一个正整数，代表小美走的最短距离。</p><h6 id="输入示例-4"><a href="#输入示例-4" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 2</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h6 id="输出示例-4"><a href="#输出示例-4" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>例程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This function will be used to read input from the console</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">readInput</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> readline = <span class="built_in">require</span>(<span class="string">&#x27;readline&#x27;</span>);</span><br><span class="line">        <span class="keyword">const</span> rl = readline.<span class="title function_">createInterface</span>(&#123;</span><br><span class="line">            <span class="attr">input</span>: process.<span class="property">stdin</span>,</span><br><span class="line">            <span class="attr">output</span>: process.<span class="property">stdout</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> input = [];</span><br><span class="line">        rl.<span class="title function_">on</span>(<span class="string">&#x27;line&#x27;</span>, <span class="function">(<span class="params">line</span>) =&gt;</span> &#123;</span><br><span class="line">            input.<span class="title function_">push</span>(line);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        rl.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(input);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is the main function to process the input and solve the problem</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> input = <span class="keyword">await</span> <span class="title function_">readInput</span>();</span><br><span class="line">    <span class="keyword">const</span> n = <span class="built_in">parseInt</span>(input[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">const</span> distances = input[<span class="number">1</span>].<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">map</span>(<span class="title class_">Number</span>);</span><br><span class="line">    <span class="keyword">const</span> [x, y] = input[<span class="number">2</span>].<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">map</span>(<span class="title class_">Number</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Function to calculate the minimum distance</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">calculateMinDistance</span>(<span class="params">n, distances, x, y</span>) &#123;</span><br><span class="line">        <span class="comment">// Normalize the indices to be zero-based</span></span><br><span class="line">        <span class="keyword">let</span> start = x - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> end = y - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If start is greater than end, swap them to make the calculation easier</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            [start, end] = [end, start];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Calculate clockwise distance</span></span><br><span class="line">        <span class="keyword">let</span> clockwiseDistance = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            clockwiseDistance += distances[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Calculate counterclockwise distance</span></span><br><span class="line">        <span class="keyword">let</span> counterClockwiseDistance = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = end; i &lt; n; i++) &#123;</span><br><span class="line">            counterClockwiseDistance += distances[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; start; i++) &#123;</span><br><span class="line">            counterClockwiseDistance += distances[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return the minimum of the two distances</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">min</span>(clockwiseDistance, counterClockwiseDistance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> minDistance = <span class="title function_">calculateMinDistance</span>(n, distances, x, y);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(minDistance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call the main function</span></span><br><span class="line"><span class="title function_">main</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3、小美的蛋糕切割"><a href="#3、小美的蛋糕切割" class="headerlink" title="3、小美的蛋糕切割"></a>3、小美的蛋糕切割</h3><h6 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h6><p>小美有一个矩形的蛋糕，共分成了 n 行 m 列，共 n * m 个区域，每个区域是一个小正方形，已知蛋糕每个区域都有一个美味度。<br>她想切一刀把蛋糕切成两部分，自己吃一部分，小团吃另一部分。 <br>小美希望两个人吃的部分的美味度之和尽可能接近，请你输出|s1 - s2|的最小值。（其中 s1 代表小美吃的美味度，s2 代表小团吃的美味度）。 请务必保证，切下来的区域都是完整的，即不能把某个小正方形切成两个小区域。</p><h6 id="输入描述-4"><a href="#输入描述-4" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行输出两个正整数 n 和 m（1 &lt;&#x3D; n, m &lt;&#x3D; 10^3），代表蛋糕区域的行数和列数。接下来的 n 行，每行输入 m 个正整数 aij（1 &lt;&#x3D; aij &lt;&#x3D; 10^4），用来表示每个区域的美味度。</p><h6 id="输出描述-4"><a href="#输出描述-4" class="headerlink" title="输出描述"></a>输出描述</h6><p>一个整数，代表|s1-s2|的最小值。</p><h6 id="输入示例-5"><a href="#输入示例-5" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 3</span><br><span class="line">1 1 4</span><br><span class="line">5 1 4</span><br></pre></td></tr></table></figure><h6 id="输出示例-5"><a href="#输出示例-5" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h6 id="提示信息-1"><a href="#提示信息-1" class="headerlink" title="提示信息"></a>提示信息</h6><p>把蛋糕像这样切开：<br>1 1 | 4 <br>5 1 | 4 <br>左边蛋糕美味度之和是 8 右边蛋糕美味度之和是 8 所以答案是 0。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4、小美的字符串变换"><a href="#4、小美的字符串变换" class="headerlink" title="4、小美的字符串变换"></a>4、小美的字符串变换</h3><p>时间限制：1.000S  空间限制：256MB</p><h6 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h6><p>小美拿到了一个长度为 n 的字符串，她希望将字符串从左到右平铺成一个矩阵（先平铺第一行，然后是第二行，以此类推，矩阵有 x 行 y 列，必须保证 x * y&#x3D;n，即每 y 个字符换行，共 x 行）。 <br>该矩阵的权值定义为这个矩阵的连通块数量。小美希望最终矩阵的权值尽可能小，你能帮小美求出这个最小权值吗？ <br>注：我们定义，上下左右四个方向相邻的相同字符是连通的。</p><h6 id="输入描述-5"><a href="#输入描述-5" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行输入一个正整数 n（1 &lt;&#x3D; n &lt;&#x3D; 10^4），代表字符串的长度。 <br>第二行输入一个长度为 n 的、仅由小写字母组成的字符串。</p><h6 id="输出描述-5"><a href="#输出描述-5" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个整数表示最小权值。</p><h6 id="输入示例-6"><a href="#输入示例-6" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">aababbabb</span><br></pre></td></tr></table></figure><h6 id="输出示例-6"><a href="#输出示例-6" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h6 id="提示信息-2"><a href="#提示信息-2" class="headerlink" title="提示信息"></a>提示信息</h6><p>平铺为 3 * 3 的矩阵：<br>aab<br>abb<br>abb <br>共有 2 个连通块，4 个 a 和 5 个 b。</p><h3 id="5、小美的树上染色"><a href="#5、小美的树上染色" class="headerlink" title="5、小美的树上染色"></a>5、小美的树上染色</h3><p>时间限制：1.000S  空间限制：256MB</p><h6 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h6><p>小美拿到了一棵树，每个节点有一个权值。初始每个节点都是白色。 <br>小美有若干次操作，每次操作可以选择两个相邻的节点，如果它们都是白色且权值的乘积是完全平方数，小美就可以把这两个节点同时染红。 <br>小美想知道，自己最多可以染红多少个节点？</p><h6 id="输入描述-6"><a href="#输入描述-6" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行输入一个正整数 n（1 &lt;&#x3D; n &lt;&#x3D; 10^5），代表节点的数量。第二行输入 n 个正整数 ai（1 &lt;&#x3D; ai &lt;&#x3D; 10^9），代表每个节点的权值。接下来的 n - 1 行，每行输入两个正整数 u，v（1 &lt;&#x3D; u, v &lt;&#x3D; n），代表节点 u 和节点 v 有一条边连接。</p><h6 id="输出描述-6"><a href="#输出描述-6" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个整数，表示最多可以染红的节点数量。</p><h6 id="输入示例-7"><a href="#输入示例-7" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3 3 12</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h6 id="输出示例-7"><a href="#输出示例-7" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h6 id="提示信息-3"><a href="#提示信息-3" class="headerlink" title="提示信息"></a>提示信息</h6><p>可以染红第二个和第三个节点。 <br>请注意，此时不能再染红第一个和第二个节点，因为第二个节点已经被染红。 因此，最多染红 2 个节点。</p>]]></content>
    
    
    <summary type="html">参加的笔试题目集锦</summary>
    
    
    
    <category term="笔面记录" scheme="https://chenjh3061/personalWeb.github.io/categories/%E7%AC%94%E9%9D%A2%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="笔试题" scheme="https://chenjh3061/personalWeb.github.io/tags/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>算法(二)————动态规划</title>
    <link href="https://chenjh3061/personalWeb.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://chenjh3061/personalWeb.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2024-05-28T09:05:11.000Z</published>
    <updated>2024-06-10T11:08:36.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1>]]></content>
    
    
    <summary type="html">动态规划、多维动态规划</summary>
    
    
    
    <category term="学习笔记" scheme="https://chenjh3061/personalWeb.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://chenjh3061/personalWeb.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>算法(三)————做题技巧</title>
    <link href="https://chenjh3061/personalWeb.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/%E5%81%9A%E9%A2%98%E6%8A%80%E5%B7%A7/"/>
    <id>https://chenjh3061/personalWeb.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/%E5%81%9A%E9%A2%98%E6%8A%80%E5%B7%A7/</id>
    <published>2024-05-28T02:35:22.000Z</published>
    <updated>2024-08-04T08:51:00.580Z</updated>
    
    <content type="html"><![CDATA[<p>总提醒：<br>    多考虑一些特殊情况，题目前面的判断。</p><h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><p>哈希表可以处理很多查找情况，优化解题速度甚至提供新解法。当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。<br>用真表做难实现就用数组模拟。<br>JS中注意map和set的特性，记住用法和原理。</p><p>例题：1两数之和、560和为k的子数组、242有效字母异位词、<br>三数之和四数之和就要考虑多指针做法，用哈希去重很麻烦</p><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><p>运用快慢两个指针解题，（头头指针&#x2F;快慢指针，头尾指针）能够大大缩短本身可能需要$O(n^2)$复杂度的遍历时间。</p><p>例题：力扣283移动零、11盛水最多的容器、15三数之和、16最接近的三数之和、力扣977有序数组的平方、[[笔试题目#1、[删除升序数组重复元素]：|删除升序数组重复元素]]、</p><p>&#x3D;&#x3D;总之看到暴力法需要两层for循环的，就想想能不能用双指针&#x3D;&#x3D;。</p><p>三数之和、四数之和，用双指针配合for循环。</p><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>分定宽和不定宽两种，如果需要查找窗内元素可以借助map。</p><p>例题：力扣3无重复字符的最长子串(配合哈希)、483找到字符串中所有字母异位词（配合map）、</p><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a><br>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长</strong> <strong>子串</strong>的长度。<br><strong>示例 1:</strong><br><strong>输入:</strong> s &#x3D; “abcabcbb”<br><strong>输出:</strong> 3<br><strong>解释:</strong> 因为无重复字符的最长子串是 <code>&quot;abc&quot;</code>，所以其长度为 3。<br><strong>示例 2:</strong><br><strong>输入:</strong> s &#x3D; “bbbbb”<br><strong>输出:</strong> 1<br><strong>解释:</strong> 因为无重复字符的最长子串是 <code>&quot;b&quot;</code>，所以其长度为 1。<br><strong>示例 3:</strong><br><strong>输入:</strong> s &#x3D; “pwwkew”<br><strong>输出:</strong> 3<br><strong>解释:</strong> 因为无重复字符的最长子串是 <code>&quot;wke&quot;</code>，所以其长度为 3。<br>     请注意，你的答案必须是 <strong>子串</strong> 的长度，<code>&quot;pwke&quot;</code> 是一个_子序列，_不是子串。****</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="title class_">Set</span>(); <span class="comment">// 用于存储当前窗口内的字符</span></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>; <span class="comment">// 左指针，遍历字符</span></span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">0</span>; <span class="comment">// 存储最长子串长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> right = <span class="number">0</span>; right &lt; s.<span class="property">length</span>; right++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (res.<span class="title function_">has</span>(s[right])) &#123; <span class="comment">// 如果当前字符已在集合中，移动左指针</span></span><br><span class="line">            res.<span class="title function_">delete</span>(s[left]);</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="title function_">add</span>(s[right]);</span><br><span class="line">        ans = <span class="title class_">Math</span>.<span class="title function_">max</span>(ans, right - left + <span class="number">1</span>); <span class="comment">// 更新最大长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h1><p>例题：[[数组链表哈希表#^218568|力扣560和为K的子数组]]、</p><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><p>探索所有可能的候选解来找出所有的解的算法，如果候选解被确认不是一个解(或者至少不是最后一个解)，回溯算法会通过在上一步进行一些变化抛弃该解，即回溯并再次尝试。</p><p>例题：力扣46全排列、</p>]]></content>
    
    
    <summary type="html">双指针、螺旋矩阵、</summary>
    
    
    
    <category term="学习笔记" scheme="https://chenjh3061/personalWeb.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://chenjh3061/personalWeb.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>算法(一)————排序算法</title>
    <link href="https://chenjh3061/personalWeb.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://chenjh3061/personalWeb.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2024-05-28T00:52:22.000Z</published>
    <updated>2024-05-28T02:38:57.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>利用堆的属性，在建堆的过程中实现大顶堆和小顶堆，完美解决“第几大&#x2F;小的数”问题。</p><p>堆是一种满足特定条件的完全二叉树，分为小顶堆和大顶堆两种。JAVA，C++这种老牌语言可以使用优先队列实现堆，JS&#x2F;TS可以用数组&#x2F;二叉树来表示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//示例代码:</span><br><span class="line">    /** </span><br><span class="line">     * @param &#123;number[]&#125; nums </span><br><span class="line">     * @param &#123;number&#125; k </span><br><span class="line">     * @return &#123;number&#125; </span><br><span class="line">     */  </span><br><span class="line">     // 整个流程就是上浮下沉  </span><br><span class="line">    var findKthLargest = function(nums, k) &#123;  </span><br><span class="line">       let heapSize=nums.length  </span><br><span class="line">        buildMaxHeap(nums,heapSize) // 构建好了一个大顶堆  </span><br><span class="line">        // 进行下沉 大顶堆是最大元素下沉到末尾  </span><br><span class="line">        for(let i=nums.length-1;i&gt;=nums.length-k+1;i--)&#123;  </span><br><span class="line">            swap(nums,0,i)  </span><br><span class="line">            --heapSize // 下沉后的元素不参与到大顶堆的调整  </span><br><span class="line">            // 重新调整大顶堆  </span><br><span class="line">             maxHeapify(nums, 0, heapSize);  </span><br><span class="line">        &#125;  </span><br><span class="line">        return nums[0]  </span><br><span class="line">       // 自下而上构建一颗大顶堆  </span><br><span class="line">       function buildMaxHeap(nums,heapSize)&#123;  </span><br><span class="line">         for(let i=Math.floor(heapSize/2)-1;i&gt;=0;i--)&#123;  </span><br><span class="line">            maxHeapify(nums,i,heapSize)  </span><br><span class="line">         &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       // 从左向右，自上而下的调整节点  </span><br><span class="line">       function maxHeapify(nums,i,heapSize)&#123;  </span><br><span class="line">           let l=i*2+1  </span><br><span class="line">           let r=i*2+2  </span><br><span class="line">           let largest=i  </span><br><span class="line">           if(l &lt; heapSize &amp;&amp; nums[l] &gt; nums[largest])&#123;  </span><br><span class="line">               largest=l  </span><br><span class="line">           &#125;  </span><br><span class="line">           if(r &lt; heapSize &amp;&amp; nums[r] &gt; nums[largest])&#123;  </span><br><span class="line">               largest=r  </span><br><span class="line">           &#125;  </span><br><span class="line">           if(largest!==i)&#123;  </span><br><span class="line">               swap(nums,i,largest) // 进行节点调整  </span><br><span class="line">               // 继续调整下面的非叶子节点  </span><br><span class="line">               maxHeapify(nums,largest,heapSize)  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       function swap(a,  i,  j)&#123;  </span><br><span class="line">            let temp = a[i];  </span><br><span class="line">            a[i] = a[j];  </span><br><span class="line">            a[j] = temp;  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;;  </span><br></pre></td></tr></table></figure><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1>]]></content>
    
    
    <summary type="html">希尔排序、快速排序、插入排序</summary>
    
    
    
    <category term="学习笔记" scheme="https://chenjh3061/personalWeb.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://chenjh3061/personalWeb.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据结构(三)————堆、图</title>
    <link href="https://chenjh3061/personalWeb.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86%20%E5%9B%BE/"/>
    <id>https://chenjh3061/personalWeb.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86%20%E5%9B%BE/</id>
    <published>2024-05-27T02:25:34.000Z</published>
    <updated>2024-06-13T15:42:33.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>利用堆进行排序，可以完美解决“第几大&#x2F;小的数”问题。<br>堆是一种满足特定条件的完全二叉树，分为小顶堆和大顶堆两种。JAVA，C++这种老牌语言可以使用优先队列实现堆，JS&#x2F;TS可以用数组&#x2F;二叉树来表示。</p><h2 id="典型题目："><a href="#典型题目：" class="headerlink" title="典型题目："></a>典型题目：</h2><table><thead><tr><th>题目</th><th align="right">力扣链接</th><th align="right">解法</th><th align="right">评价</th></tr></thead><tbody><tr><td>数组中的第K个最大元素</td><td align="right"><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/?envType=study-plan-v2&envId=top-100-liked">数组中的第K个最大元素</a></td><td align="right">堆排序</td><td align="right">标准例程，牢记！</td></tr><tr><td></td><td align="right"></td><td align="right"></td><td align="right"></td></tr></tbody></table><p>例题： <a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/?envType=study-plan-v2&envId=top-100-liked">力扣215:数组中的第K个最大元素</a></p><p>示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; nums </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; k </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125; </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"> <span class="comment">// 整个流程就是上浮下沉  </span></span><br><span class="line"><span class="keyword">var</span> findKthLargest = <span class="keyword">function</span>(<span class="params">nums, k</span>) &#123;  </span><br><span class="line">   <span class="keyword">let</span> heapSize=nums.<span class="property">length</span>  </span><br><span class="line">    <span class="title function_">buildMaxHeap</span>(nums,heapSize) <span class="comment">// 构建好了一个大顶堆  </span></span><br><span class="line">    <span class="comment">// 进行下沉 大顶堆是最大元素下沉到末尾  </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=nums.<span class="property">length</span>-<span class="number">1</span>;i&gt;=nums.<span class="property">length</span>-k+<span class="number">1</span>;i--)&#123;  </span><br><span class="line">        <span class="title function_">swap</span>(nums,<span class="number">0</span>,i)  </span><br><span class="line">        --heapSize <span class="comment">// 下沉后的元素不参与到大顶堆的调整  </span></span><br><span class="line">        <span class="comment">// 重新调整大顶堆  </span></span><br><span class="line">         <span class="title function_">maxHeapify</span>(nums, <span class="number">0</span>, heapSize);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>]  </span><br><span class="line">   <span class="comment">// 自下而上构建一颗大顶堆  </span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">buildMaxHeap</span>(<span class="params">nums,heapSize</span>)&#123;  </span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="title class_">Math</span>.<span class="title function_">floor</span>(heapSize/<span class="number">2</span>)-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;  </span><br><span class="line">        <span class="title function_">maxHeapify</span>(nums,i,heapSize)  </span><br><span class="line">     &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">// 从左向右，自上而下的调整节点  </span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">maxHeapify</span>(<span class="params">nums,i,heapSize</span>)&#123;  </span><br><span class="line">       <span class="keyword">let</span> l=i*<span class="number">2</span>+<span class="number">1</span>  </span><br><span class="line">       <span class="keyword">let</span> r=i*<span class="number">2</span>+<span class="number">2</span>  </span><br><span class="line">       <span class="keyword">let</span> largest=i  </span><br><span class="line">       <span class="keyword">if</span>(l &lt; heapSize &amp;&amp; nums[l] &gt; nums[largest])&#123;  </span><br><span class="line">           largest=l  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">if</span>(r &lt; heapSize &amp;&amp; nums[r] &gt; nums[largest])&#123;  </span><br><span class="line">           largest=r  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">if</span>(largest!==i)&#123;  </span><br><span class="line">           <span class="title function_">swap</span>(nums,i,largest) <span class="comment">// 进行节点调整  </span></span><br><span class="line">           <span class="comment">// 继续调整下面的非叶子节点  </span></span><br><span class="line">           <span class="title function_">maxHeapify</span>(nums,largest,heapSize)  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">swap</span>(<span class="params">a,  i,  j</span>)&#123;  </span><br><span class="line">        <span class="keyword">let</span> temp = a[i];  </span><br><span class="line">        a[i] = a[j];  </span><br><span class="line">        a[j] = temp;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>二维坐标中，两点可以连成线，多个点之间连线就构成了<strong>图</strong>。<strong>图</strong>也可以只存在一个节点或者没有节点(<strong>空图</strong>)。</p><p>图分为<strong>有向图</strong>和<strong>无向图</strong>两种，或者根据任意两个节点能否到达分为<strong>连通图</strong>和<strong>非连通图</strong>；边可以<em>加权</em>。（注意强连通图，是有向图中任意两个节点都可到达）。</p><p>无向图中某一节点的度就是上面连接的边的数目，有向图的节点则有出度和入度。在无向图中的<strong>极大连通子图</strong>称之为该图的一个<strong>连通分量</strong>。在有向图中<strong>极大强连通子图</strong>称之为该图的<strong>强连通分量</strong>。</p><h2 id="图的构造"><a href="#图的构造" class="headerlink" title="图的构造"></a>图的构造</h2><p>图可以用邻接表、邻接矩阵或者类表示。</p><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>用二维数组标示图<br>![[邻接矩阵.png]]<br>邻接矩阵的优点：</p><ul><li>表达方式简单，易于理解</li><li>检查任意两个顶点间是否存在边的操作非常快</li><li>适合稠密图，在边数接近顶点数平方的图中，邻接矩阵是一种空间效率较高的表示方法。<br>缺点：</li><li>遇到稀疏图，会导致申请过大的二维数组造成空间浪费 且遍历 边 的时候需要遍历整个n * n矩阵，造成时间浪费</li></ul><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>邻接表 使用 数组 + 链表的方式来表示。邻接表是从边的数量来表示图，有多少边 才会申请对应大小的链表。</p><p>邻接表的构造如图：<br>![[邻接表.png]]<br>邻接表的优点：</p><ul><li>对于稀疏图的存储，只需要存储边，空间利用率高</li><li>遍历节点连接情况相对容易<br>缺点：</li><li>检查任意两个节点间是否存在边，效率相对低，需要 O(V)时间，V表示某节点连接其他节点的数量。</li><li>实现相对复杂，不易理解</li></ul><h3 id="图的遍历方式"><a href="#图的遍历方式" class="headerlink" title="图的遍历方式"></a>图的遍历方式</h3><ul><li>深度优先搜索（dfs）</li><li>广度优先搜索（bfs）</li></ul><p>例题：[力扣200:岛屿数量][anchor-id]（有意思的搜索题目）</p><h2 id="典型题目：-1"><a href="#典型题目：-1" class="headerlink" title="典型题目："></a>典型题目：</h2><table><thead><tr><th>题目</th><th align="right">力扣链接</th><th align="right">解法</th><th align="right">评价</th></tr></thead><tbody><tr><td></td><td align="right"></td><td align="right"></td><td align="right"></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">堆、堆排序；图、深度优先、广度优先</summary>
    
    
    
    <category term="学习笔记" scheme="https://chenjh3061/personalWeb.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://chenjh3061/personalWeb.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络总纲</title>
    <link href="https://chenjh3061/personalWeb.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%80%BB%E7%BA%B2/"/>
    <id>https://chenjh3061/personalWeb.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%80%BB%E7%BA%B2/</id>
    <published>2024-03-10T04:25:34.000Z</published>
    <updated>2024-03-10T10:54:35.190Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h2 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h2><h2 id="数据的表示和运算"><a href="#数据的表示和运算" class="headerlink" title="数据的表示和运算"></a>数据的表示和运算</h2><h2 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h2><h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><h2 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h2><h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><h2 id="输入-输出系统"><a href="#输入-输出系统" class="headerlink" title="输入&#x2F;输出系统"></a>输入&#x2F;输出系统</h2>]]></content>
    
    
    <summary type="html">学习记录</summary>
    
    
    
    <category term="学习笔记" scheme="https://chenjh3061/personalWeb.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://chenjh3061/personalWeb.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络总纲</title>
    <link href="https://chenjh3061/personalWeb.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BA%B2/"/>
    <id>https://chenjh3061/personalWeb.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BA%B2/</id>
    <published>2024-03-10T02:25:34.000Z</published>
    <updated>2024-04-07T01:43:55.602Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><h3 id="计算机网络的概念、组成、分类"><a href="#计算机网络的概念、组成、分类" class="headerlink" title="计算机网络的概念、组成、分类"></a>计算机网络的概念、组成、分类</h3><h3 id="体系结构-与-分层结构"><a href="#体系结构-与-分层结构" class="headerlink" title="体系结构 与 分层结构"></a>体系结构 与 分层结构</h3><h3 id="ISO-OSI参考模型和TCP-IP模型"><a href="#ISO-OSI参考模型和TCP-IP模型" class="headerlink" title="ISO&#x2F;OSI参考模型和TCP&#x2F;IP模型"></a>ISO&#x2F;OSI参考模型和TCP&#x2F;IP模型</h3><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2>]]></content>
    
    
    <summary type="html">学习记录</summary>
    
    
    
    <category term="学习笔记" scheme="https://chenjh3061/personalWeb.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://chenjh3061/personalWeb.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据结构总纲</title>
    <link href="https://chenjh3061/personalWeb.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/"/>
    <id>https://chenjh3061/personalWeb.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/</id>
    <published>2024-03-04T02:25:34.000Z</published>
    <updated>2024-05-28T00:54:35.232Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><h3 id="数据结构（三要素）"><a href="#数据结构（三要素）" class="headerlink" title="数据结构（三要素）"></a>数据结构（三要素）</h3><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><h5 id="线性结构：线性表、栈、队列"><a href="#线性结构：线性表、栈、队列" class="headerlink" title="线性结构：线性表、栈、队列"></a>线性结构：线性表、栈、队列</h5><h5 id="树、图、集合"><a href="#树、图、集合" class="headerlink" title="树、图、集合"></a>树、图、集合</h5><h4 id="存储结构（物理结构）"><a href="#存储结构（物理结构）" class="headerlink" title="存储结构（物理结构）"></a>存储结构（物理结构）</h4><h4 id="数据的运算"><a href="#数据的运算" class="headerlink" title="数据的运算"></a>数据的运算</h4><h3 id="五个特征"><a href="#五个特征" class="headerlink" title="五个特征"></a>五个特征</h3><h4 id="算法定义"><a href="#算法定义" class="headerlink" title="算法定义"></a>算法定义</h4><h4 id="五个特征：有穷性、确定性、可行性、输入、输出"><a href="#五个特征：有穷性、确定性、可行性、输入、输出" class="headerlink" title="五个特征：有穷性、确定性、可行性、输入、输出"></a>五个特征：有穷性、确定性、可行性、输入、输出</h4><h4 id="效率的度量"><a href="#效率的度量" class="headerlink" title="效率的度量"></a>效率的度量</h4><h5 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h5><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><h4 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h4><h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><h4 id="单链表、双链表、循环链表（指针实现）"><a href="#单链表、双链表、循环链表（指针实现）" class="headerlink" title="单链表、双链表、循环链表（指针实现）"></a>单链表、双链表、循环链表（指针实现）</h4><h4 id="静态链表（数组实现）"><a href="#静态链表（数组实现）" class="headerlink" title="静态链表（数组实现）"></a>静态链表（数组实现）</h4><h2 id="栈、队列和数组"><a href="#栈、队列和数组" class="headerlink" title="栈、队列和数组"></a>栈、队列和数组</h2><h3 id="操作受限"><a href="#操作受限" class="headerlink" title="操作受限"></a>操作受限</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><h5 id="顺序栈、链共享栈"><a href="#顺序栈、链共享栈" class="headerlink" title="顺序栈、链共享栈"></a>顺序栈、链共享栈</h5><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><h5 id="循环队列、链式队列、双端队列"><a href="#循环队列、链式队列、双端队列" class="headerlink" title="循环队列、链式队列、双端队列"></a>循环队列、链式队列、双端队列</h5><h3 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h3><h4 id="数组（重点易错，回看）"><a href="#数组（重点易错，回看）" class="headerlink" title="数组（重点易错，回看）"></a><strong>数组</strong>（重点易错，回看）</h4><h5 id="一维数组、多维数组（压缩存储、稀疏矩阵）"><a href="#一维数组、多维数组（压缩存储、稀疏矩阵）" class="headerlink" title="一维数组、多维数组（压缩存储、稀疏矩阵）"></a>一维数组、多维数组（压缩存储、稀疏矩阵）</h5><h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><h3 id="基本概念：主串、子串、串长"><a href="#基本概念：主串、子串、串长" class="headerlink" title="基本概念：主串、子串、串长"></a>基本概念：主串、子串、串长</h3><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><h4 id="定长顺序存储"><a href="#定长顺序存储" class="headerlink" title="定长顺序存储"></a>定长顺序存储</h4><h4 id="堆分配存储"><a href="#堆分配存储" class="headerlink" title="堆分配存储"></a>堆分配存储</h4><h4 id="块链存储"><a href="#块链存储" class="headerlink" title="块链存储"></a>块链存储</h4><h3 id="模式匹配算法"><a href="#模式匹配算法" class="headerlink" title="模式匹配算法"></a>模式匹配算法</h3><h4 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h4><h4 id="KMP：部分匹配值表、next数组、next函数推理过程"><a href="#KMP：部分匹配值表、next数组、next函数推理过程" class="headerlink" title="KMP：部分匹配值表、next数组、next函数推理过程"></a>KMP：部分匹配值表、next数组、next函数推理过程</h4><h4 id="KMP算法的进一步改进"><a href="#KMP算法的进一步改进" class="headerlink" title="KMP算法的进一步改进"></a>KMP算法的进一步改进</h4><h2 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="概念、定义、存储结构"><a href="#概念、定义、存储结构" class="headerlink" title="概念、定义、存储结构"></a>概念、定义、存储结构</h4><h4 id="操作：三种遍历、线索二叉树"><a href="#操作：三种遍历、线索二叉树" class="headerlink" title="操作：三种遍历、线索二叉树"></a>操作：三种遍历、线索二叉树</h4><h4 id="应用：并查集、哈夫曼树"><a href="#应用：并查集、哈夫曼树" class="headerlink" title="应用：并查集、哈夫曼树"></a>应用：并查集、哈夫曼树</h4><h3 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h3><h4 id="概念：定义、存储结构"><a href="#概念：定义、存储结构" class="headerlink" title="概念：定义、存储结构"></a>概念：定义、存储结构</h4><h4 id="操作：与二叉树的转换、遍历"><a href="#操作：与二叉树的转换、遍历" class="headerlink" title="操作：与二叉树的转换、遍历"></a>操作：与二叉树的转换、遍历</h4><h4 id="应用：并查集"><a href="#应用：并查集" class="headerlink" title="应用：并查集"></a>应用：并查集</h4><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2>]]></content>
    
    
    <summary type="html">数据结构大纲</summary>
    
    
    
    <category term="学习笔记" scheme="https://chenjh3061/personalWeb.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://chenjh3061/personalWeb.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据结构（一）——绪论&amp;数组、链表、哈希表、字符串</title>
    <link href="https://chenjh3061/personalWeb.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://chenjh3061/personalWeb.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2024-03-03T02:25:34.000Z</published>
    <updated>2024-08-09T03:12:07.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0、引"><a href="#0、引" class="headerlink" title="0、引"></a>0、引</h1><p>这里记录一些题目收集情况，主要逻辑来自 <a href="https://www.programmercarl.com/">代码随想录</a></p><h1 id="·数组"><a href="#·数组" class="headerlink" title="·数组"></a>·数组</h1><p>经常结合双指针法</p><h2 id="典型题目："><a href="#典型题目：" class="headerlink" title="典型题目："></a>典型题目：</h2><table><thead><tr><th>题目</th><th>力扣链接</th><th>解法</th><th>评价</th></tr></thead><tbody><tr><td>移除元素</td><td><a href="https://leetcode.cn/problems/remove-element/description/">移除元素</a></td><td>推荐双指针</td><td>触类旁通</td></tr><tr><td>有序数组平方</td><td><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">有序数组平方</a></td><td>双指针</td><td></td></tr><tr><td>[[笔试题目#2、[螺旋矩阵]|螺旋矩阵]]</td><td><a href="https://leetcode.cn/problems/spiral-matrix-ii/">螺旋矩阵</a></td><td>背代码</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h1 id="·链表"><a href="#·链表" class="headerlink" title="·链表"></a>·链表</h1><p>数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。</p><p>链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。</p><h2 id="典型题目：-1"><a href="#典型题目：-1" class="headerlink" title="典型题目："></a>典型题目：</h2><table><thead><tr><th>题目</th><th align="right">力扣链接</th><th align="right">解法</th><th align="right">评价</th></tr></thead><tbody><tr><td>链表理论</td><td align="right"><a href="https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%93%BE%E8%A1%A8%E7%9A%84%E7%B1%BB%E5%9E%8B">链表理论</a></td><td align="right">整节都是好东西</td><td align="right">都是经典题目</td></tr><tr><td>链表相交</td><td align="right"><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/">链表相交</a></td><td align="right">哈希表（存储+查找）、双指针（数学证明有相交能相遇，无相交会同时NULL）、硬解（谁长先先多走）</td><td align="right">很有意思的题目</td></tr><tr><td>设计链表</td><td align="right">707</td><td align="right">基本功</td><td align="right">对链表的详细理解</td></tr><tr><td></td><td align="right"></td><td align="right"></td><td align="right"></td></tr></tbody></table><h1 id="·哈希表"><a href="#·哈希表" class="headerlink" title="·哈希表"></a>·哈希表</h1><p>一般用于快速判断一个元素是否出现在集合里。哈希法是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组、set或者是map来存放数据，才能实现快速的查找。</p><p>如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！</p><h2 id="典型题目：-2"><a href="#典型题目：-2" class="headerlink" title="典型题目："></a>典型题目：</h2><table><thead><tr><th>题目</th><th align="right">力扣链接</th><th align="right">解法</th><th align="right">评价</th></tr></thead><tbody><tr><td>[和为K的子数组]</td><td align="right"><a href="https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&envId=top-100-liked">和为K的子数组</a></td><td align="right">改良遍历(超时)&#x2F;前缀和+哈希</td><td align="right">有意思</td></tr><tr><td></td><td align="right"></td><td align="right"></td><td align="right"></td></tr><tr><td></td><td align="right"></td><td align="right"></td><td align="right"></td></tr><tr><td></td><td align="right"></td><td align="right"></td><td align="right"></td></tr><tr><td></td><td align="right"></td><td align="right"></td><td align="right"></td></tr></tbody></table><p>^218568</p><h1 id="·字符串"><a href="#·字符串" class="headerlink" title="·字符串"></a>·字符串</h1><h2 id="典型题目：-3"><a href="#典型题目：-3" class="headerlink" title="典型题目："></a>典型题目：</h2><table><thead><tr><th>题目</th><th align="right">力扣链接</th><th align="right">解法</th><th align="right">评价</th></tr></thead><tbody><tr><td>[反转字符串]</td><td align="right">[反转字符串1][anchor-7]<br>[反转字符串2][anchor-8]<br></td><td align="right">调换</td><td align="right">多想</td></tr><tr><td>翻转字符串中的单词</td><td align="right">[反转字符串中的单词][anchor-9]</td><td align="right">分步骤解决</td><td align="right">好题目</td></tr><tr><td></td><td align="right"></td><td align="right"></td><td align="right"></td></tr><tr><td></td><td align="right"></td><td align="right"></td><td align="right"></td></tr><tr><td></td><td align="right"></td><td align="right"></td><td align="right"></td></tr><tr><td>[anchor-7]:<a href="https://leetcode.cn/problems/reverse-string/description/">https://leetcode.cn/problems/reverse-string/description/</a></td><td align="right"></td><td align="right"></td><td align="right"></td></tr><tr><td>[anchor-8]:<a href="https://leetcode.cn/problems/reverse-string-ii/">https://leetcode.cn/problems/reverse-string-ii/</a></td><td align="right"></td><td align="right"></td><td align="right"></td></tr><tr><td>[anchor-9]:<a href="https://leetcode.cn/problems/reverse-words-in-a-string/description/">https://leetcode.cn/problems/reverse-words-in-a-string/description/</a></td><td align="right"></td><td align="right"></td><td align="right"></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">学习记录</summary>
    
    
    
    <category term="学习笔记" scheme="https://chenjh3061/personalWeb.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://chenjh3061/personalWeb.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://chenjh3061/personalWeb.github.io/hello-world/"/>
    <id>https://chenjh3061/personalWeb.github.io/hello-world/</id>
    <published>2024-03-02T15:10:25.703Z</published>
    <updated>2024-05-28T00:50:30.129Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.<br><a href="https://www.zhihu.com/column/c_1502937018040057858">https://www.zhihu.com/column/c_1502937018040057858</a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new (post) <span class="string">&quot;My New Post&quot;</span>    (post可写可不写)  </span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server / hexo s</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p>常见命令：<br>hexo new “postName”      # 新建文章<br>hexo new page “pageName” # 新建页面<br>hexo generate            # 生成静态页面至public目录<br>hexo server              # 开启预览访问端口（默认端口4000，’ctrl + c’关闭server）<br>hexo deploy              # 部署到GitHub<br>hexo help                # 查看帮助<br>hexo version             # 查看Hexo的版本<br>缩写命令：<br>hexo n &#x3D;&#x3D; hexo new<br>hexo g &#x3D;&#x3D; hexo generate<br>hexo s &#x3D;&#x3D; hexo server<br>hexo d &#x3D;&#x3D; hexo deploy<br>组合命令：<br>hexo s -g   # 生成并本地预览<br>hexo d -g   # 生成并上传</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt;</summary>
        
      
    
    
    
    
  </entry>
  
</feed>
