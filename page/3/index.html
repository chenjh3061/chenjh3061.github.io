<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"chenjh3061","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="个人记录">
<meta property="og:type" content="website">
<meta property="og:title" content="joho world">
<meta property="og:url" content="https://chenjh3061/personalWeb.github.io/page/3/index.html">
<meta property="og:site_name" content="joho world">
<meta property="og:description" content="个人记录">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Joho Chen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://chenjh3061/personalWeb.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>joho world</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="joho world" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">joho world</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Welcome!</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenjh3061/personalWeb.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/JavaScript/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Joho Chen">
      <meta itemprop="description" content="个人记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="joho world">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/JavaScript/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-08-30 16:45:43 / 修改时间：16:45:50" itemprop="dateCreated datePublished" datetime="2024-08-30T16:45:43+08:00">2024-08-30</time>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在 JavaScript 中，错误处理主要通过使用 throw 语句和 try…catch 块来实现。使用 throw 语句允许你创建自定义错误消息，这对于调试代码非常有用。根据你想要实现的目标，可以使用不同的方式使用 throw 语句。 </p>
<ul>
<li>抛出字符串：</li>
</ul>
<p> </p>
<p>你可以在 JavaScript 中抛出一个字符串。它将在 catch 块中被捕获为错误消息。 </p>
<p>function checkName(name) { </p>
<p>  if (name &#x3D;&#x3D;&#x3D; ‘’) { </p>
<p>    throw “Name can’t be empty!”; </p>
<p>  } </p>
<p>  return name; </p>
<p>} </p>
<p>try { </p>
<p>  console.log(checkName(‘’)); </p>
<p>} catch (error) { </p>
<p>  console.error(error); &#x2F;&#x2F; “Name can’t be empty!” </p>
<p>} </p>
<ul>
<li>抛出 Error 实例：</li>
</ul>
<p> </p>
<p>一种更常见和推荐的方法是抛出一个 Error 实例。这允许在错误中包含比如堆栈跟踪的附加元数据，有助于调试。 </p>
<p>function divide(numerator, denominator) { </p>
<p>  if (denominator &#x3D;&#x3D;&#x3D; 0) { </p>
<p>    throw new Error(“Cannot divide by zero!”); </p>
<p>  } </p>
<p>  return numerator &#x2F; denominator; </p>
<p>} </p>
<p>try { </p>
<p>  console.log(divide(5, 0)); </p>
<p>} catch (error) { </p>
<p>  console.error(error.message); &#x2F;&#x2F; “Cannot divide by zero!” </p>
<p>} </p>
<ul>
<li>抛出聚合错误：</li>
</ul>
<p> </p>
<p>有时候，你可能希望同时抛出多个错误。这在处理 Promise 时特别有用。JavaScript 有一个内置的 AggregateError 对象，可以在这类情况下使用。AggregateError 对象可以接受一个错误对象的可迭代集合和一个可选的消息作为参数。 </p>
<p>let error1 &#x3D; new Error(“First Error”); </p>
<p>let error2 &#x3D; new Error(“Second Error”); </p>
<p>try { </p>
<p>  throw new AggregateError([error1, error2], “Two errors occurred.”); </p>
<p>} catch (error) { </p>
<p>  if (error instanceof AggregateError) { </p>
<p>    console.error(error.message); &#x2F;&#x2F; “Two errors occurred.” </p>
<p>    for (let e of error.errors) { </p>
<p>      console.error(e.message); &#x2F;&#x2F; 打印 “First Error” 和 “Second Error” </p>
<p>    } </p>
<p>  } </p>
<p>}</p>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenjh3061/personalWeb.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/JavaScript/Module/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Joho Chen">
      <meta itemprop="description" content="个人记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="joho world">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/JavaScript/Module/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-08-30 16:44:21 / 修改时间：16:45:37" itemprop="dateCreated datePublished" datetime="2024-08-30T16:44:21+08:00">2024-08-30</time>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>ES6 在语言标准的层面上，实现了模块功能。ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入，和Python的import有一点点类似。 </p>
<p><b>这就是代码模块化</b></p>
<ol>
<li><p>&#x2F;&#x2F; ES6模块 </p>
</li>
<li><p>import { stat, exists, readFile } from ‘fs’;</p>
</li>
</ol>
<p> </p>
<p>由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。 </p>
<p>除了静态加载带来的各种好处，ES6 模块还有以下好处： </p>
<ul>
<li><p>不再需要UMD模块格式，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。 </p>
</li>
<li><p>将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者navigator对象的属性。 </p>
</li>
<li><p>不再需要对象作为命名空间（比如Math对象），未来这些功能可以通过模块提供。</p>
</li>
</ul>
<p> </p>
<p>import会被JS引擎静态分析，先于模块内的其他语句执行。也就是说，import和export命令只能在模块的顶层，不能在代码块之中（比如，在if代码块之中，或在函数之中）。也是因此import命令无法取代require的动态加载功能。 </p>
<p>于是ES2020提案引入import()函数，支持动态加载模块：import(specifier) </p>
<ol>
<li><p>const main &#x3D; document.querySelector(‘main’); </p>
</li>
<li><p>import(<code>./section-modules/$&#123;someVariable&#125;.js</code>) </p>
</li>
<li><p>  .then(module &#x3D;&gt; { </p>
</li>
<li><p>    module.loadPageInto(main); </p>
</li>
<li><p>  }) </p>
</li>
<li><p>  .catch(err &#x3D;&gt; { </p>
</li>
<li><p>    main.textContent &#x3D; err.message; </p>
</li>
<li><p>  });</p>
</li>
</ol>
<p> </p>
<p>ES6的模块采用严格模式： </p>
<ul>
<li><p>变量必须声明后再使用 </p>
</li>
<li><p>函数的参数不能有同名属性，否则报错 </p>
</li>
<li><p>不能使用with语句 </p>
</li>
<li><p>不能对只读属性赋值，否则报错 </p>
</li>
<li><p>不能使用前缀 0 表示八进制数，否则报错 </p>
</li>
<li><p>不能删除不可删除的属性，否则报错 </p>
</li>
<li><p>不能删除变量delete prop，会报错，只能删除属性delete global[prop] </p>
</li>
<li><p>eval不会在它的外层作用域引入变量 </p>
</li>
<li><p>eval和arguments不能被重新赋值 </p>
</li>
<li><p>arguments不会自动反映函数参数的变化 </p>
</li>
<li><p>不能使用arguments.callee </p>
</li>
<li><p>不能使用arguments.caller </p>
</li>
<li><p>禁止this指向全局对象 </p>
</li>
<li><p>不能使用fn.caller和fn.arguments获取函数调用的堆栈 </p>
</li>
<li><p>增加了保留字（比如protected、static和interface）</p>
</li>
</ul>
<p>1、export命令： </p>
<p>用于规定模块的对外接口，可以用export来重用代码块，把在一个js中定义的东西导出到别的地方也可以用<br>![[Pasted image 20240830164527.png]]</p>
<p>Export default 可以创建默认导出，文件中只有一个值需要导出的时候可以这样写，这样的导出，在导入的时候不用加大括号。注意导出语句必须在模块顶层！ </p>
<p>模块引入的为静态量，不可修改。借助export可以生成跨模块常量。 </p>
<p>导出导入可以一起用： </p>
<ol start="2">
<li><p>export { foo, bar } from ‘my_module’; </p>
</li>
<li><p>&#x2F;&#x2F; 可以简单理解为 </p>
</li>
<li><p>import { foo, bar } from ‘my_module’; </p>
</li>
<li><p>export { foo, bar };</p>
</li>
</ol>
<p> </p>
<p>注意在写Module的时候，不要让a脚本执行依赖b，b又依赖a，这种循环加载要避免。 </p>
<p>Tip：简化导入 </p>
<ul>
<li><p>模块重导： </p>
<p>  如果不想写很多行的import，可以使用模块重导(Re-export)，也就是在对应库允许下，一次引入多个组件： </p>
<p>  &#x2F;&#x2F; 使用模块重导 </p>
<p>  import { Modal, Checkbox, Message} from ‘@arco-design&#x2F;web-react’ </p>
<p>  自己写的库要允许重导，就要在导出里面export多个成员，或者直接export * 。 </p>
</li>
<li><p>require.context: </p>
<p>  这个功能能动态导入一组模块，不需要显式一个个导。可用于配置路由、状态管理。 </p>
<p>  &#x2F;&#x2F; routes&#x2F;index.ts文件统一处理 </p>
<p>  &#x2F;&#x2F; 创建一个context来导入routes目录下所有的 .ts 文件 </p>
<p>  const routesContext &#x3D; require.context(‘.&#x2F;routes’, false, &#x2F;.ts$&#x2F;); </p>
<p>  const routes &#x3D; []; </p>
<p>  &#x2F;&#x2F; 遍历 context 中的每个模块 </p>
<p>  routesContext.keys().forEach(modulePath &#x3D;&gt; { </p>
<p>    &#x2F;&#x2F; 获取模块的导出 </p>
<p>    const route &#x3D; routesContext(modulePath); </p>
<p>    &#x2F;&#x2F; 获取组件名称【如果需要话】，例如：从 “.&#x2F;Header.ts” 提取 “Header” </p>
<p>    &#x2F;&#x2F; const routeName &#x3D; modulePath.replace(&#x2F;^.&#x2F;(.*).\w+$&#x2F;, ‘$1’); </p>
<p>    &#x2F;&#x2F; 将组件存储在组件对象中 </p>
<p>    routes.push(route.default || route) </p>
<p>  }); </p>
<p>  export default routes; </p>
</li>
<li><p>ProvidePlugin： </p>
<p>  用webpack的话可以这样写： </p>
<p>  const webpack &#x3D; require(‘webpack’); </p>
<p>  module.exports &#x3D; { </p>
<p>    &#x2F;&#x2F; 其他配置… </p>
<p>    plugins: [ </p>
<p>      new webpack.ProvidePlugin({ </p>
<p>        React: ‘react’, </p>
<p>        _: ‘lodash’, </p>
<p>        dayjs: ‘dayjs’, </p>
<p>        &#x2F;&#x2F; 假设项目中自己定义的utils.js在src目录下 </p>
<p>        Utils: path.resolve(__dirname, ‘src&#x2F;utils.js’) </p>
<p>  }) </p>
<p>      }) </p>
<p>    ] </p>
<p>    &#x2F;&#x2F; 其他配置… </p>
<p>  }; </p>
<p>  这样可以在任何地方使用导入的组件，需要谨慎使用，避免代码难以维护和不必要的打包。</p>
</li>
</ul>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenjh3061/personalWeb.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/JavaScript/%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81BOM%E3%80%81DOM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Joho Chen">
      <meta itemprop="description" content="个人记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="joho world">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/JavaScript/%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81BOM%E3%80%81DOM/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-08-30 16:43:51 / 修改时间：16:44:07" itemprop="dateCreated datePublished" datetime="2024-08-30T16:43:51+08:00">2024-08-30</time>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>![[Pasted image 20240830164357.png]]</p>
<p>二、DOM </p>
<p>DOM（文档对象模型，Document Object Model）是一个跨平台、与语言无关的接口，允许程序和脚本动态访问和更新文档的内容、结构和样式。它将 HTML、XML 文档作为一棵树状结构进行表示，其中每个节点代表文档的一部分，例如元素、属性、文本等。是Web应用的结构化的UI表现形式，至少最初由Web应用的HTML代码构成。 </p>
<p>DOM 的主要特征和功能 </p>
<ol>
<li><p>树状结构: </p>
<ul>
<li>DOM 将文档表示为一棵树，树的每个节点代表文档的一个部分。根节点通常是 <html> 元素，子节点包括 <head> 和 <body> 等元素。</li>
</ul>
<p> 
     </p>
</li>
<li><p>节点类型: </p>
<ul>
<li><p>元素节点: 代表 HTML 标签（如 <div>, <p>, <a> 等）。 </p>
</li>
<li><p>属性节点: 代表元素的属性（如 class, id, href 等）。 </p>
</li>
<li><p>文本节点: 代表元素中的文本内容。 </p>
</li>
<li><p>文档节点: 整个文档的根节点。</p>
</li>
</ul>
<p> 
     </p>
</li>
<li><p>导航和操作节点: </p>
<ul>
<li><p>通过 DOM，可以导航文档的节点树，比如访问父节点、子节点、兄弟节点等。 </p>
</li>
<li><p>提供操作节点的方法，如创建新节点、修改节点内容、添加或删除节点等。</p>
</li>
</ul>
<p> 
     </p>
</li>
<li><p>与脚本语言的交互: </p>
<ul>
<li>DOM 最常与 JavaScript 一起使用，以实现动态网页效果。例如，通过 JavaScript 可以动态修改文档的内容、结构和样式。</li>
</ul>
</li>
</ol>
<p> </p>
<p>示例代码 </p>
<p>以下是一个简单的 HTML 示例文档及其对应的 DOM 操作示例： </p>
<p>HTML 文档 </p>
<!DOCTYPE html><p> <html> <head>     <title>DOM Example</title> </head> <body>     <div id="content">         <p>Hello, World!</p>     </div> </body> </html>  </p>
<p>JavaScript 操作 DOM </p>
<p>&#x2F;&#x2F; 获取元素 const contentDiv &#x3D; document.getElementById(‘content’);  </p>
<p>&#x2F;&#x2F; 创建一个新的元素 const newParagraph &#x3D; document.createElement(‘p’); newParagraph.textContent &#x3D; ‘This is a new paragraph.’;  </p>
<p>&#x2F;&#x2F; 添加新元素到现有的节点 contentDiv.appendChild(newParagraph);  </p>
<p>&#x2F;&#x2F; 修改现有元素的内容 const oldParagraph &#x3D; contentDiv.querySelector(‘p’); oldParagraph.textContent &#x3D; ‘Hello, DOM!’;  </p>
<p>&#x2F;&#x2F; 删除现有的节点 contentDiv.removeChild(oldParagraph);  </p>
<p>常用 DOM 方法 </p>
<ul>
<li><p>获取节点: </p>
<ul>
<li><p>document.getElementById(id) </p>
</li>
<li><p>document.getElementsByClassName(className) </p>
</li>
<li><p>document.getElementsByTagName(tagName) </p>
</li>
<li><p>document.querySelector(selector) </p>
</li>
<li><p>document.querySelectorAll(selector)</p>
</li>
</ul>
<p> 
      </p>
</li>
<li><p>创建和插入节点: </p>
<ul>
<li><p>document.createElement(tagName) </p>
</li>
<li><p>parentNode.appendChild(node) </p>
</li>
<li><p>parentNode.insertBefore(newNode, referenceNode)</p>
</li>
</ul>
<p> 
      </p>
</li>
<li><p>修改节点: </p>
<ul>
<li><p>node.textContent 或 node.innerText </p>
</li>
<li><p>node.innerHTML </p>
</li>
<li><p>element.setAttribute(attributeName, attributeValue) </p>
</li>
<li><p>element.classList.add(className) </p>
</li>
<li><p>element.classList.remove(className)</p>
</li>
</ul>
<p> 
      </p>
</li>
<li><p>删除节点: </p>
<ul>
<li>parentNode.removeChild(node)</li>
</ul>
</li>
</ul>
<p> </p>
<p>总结 </p>
<p>        DOM 是 Web 开发中一个非常强大和重要的工具，它允许开发者通过脚本（主要是 JavaScript）动态地操作 HTML 和 XML 文档的结构、内容和样式，从而实现丰富的交互效果和用户体验。理解和熟练运用 DOM，对于现代 Web 开发至关重要。 </p>
<p>tip：缓存DOM引用： </p>
<p>频繁访问 DOM 会导致性能下降，因此建议缓存 DOM 引用。 </p>
<p>&#x2F;&#x2F; 不推荐 </p>
<p>function updateElement() { </p>
<p>  document.getElementById(‘myElement’).textContent &#x3D; ‘Hello’; </p>
<p>} </p>
<p>&#x2F;&#x2F; 推荐 </p>
<p>const myElement &#x3D; document.getElementById(‘myElement’); </p>
<p>function updateElement() { </p>
<p>  myElement.textContent &#x3D; ‘Hello’; </p>
<p>}</p>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenjh3061/personalWeb.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/JavaScript/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Joho Chen">
      <meta itemprop="description" content="个人记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="joho world">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/JavaScript/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-08-30 16:42:14 / 修改时间：16:42:23" itemprop="dateCreated datePublished" datetime="2024-08-30T16:42:14+08:00">2024-08-30</time>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>引子：回调地域（callback hell） </p>
<p>指在异步 JavaScript 代码中出现的多层嵌套回调函数的情况，导致代码难以理解、维护和调试的现象。这种情况通常在处理多个异步操作时出现，每个操作都需要等待上一个操作完成才能执行，因此需要嵌套使用回调函数。这样的代码结构会导致代码缩进增加、可读性降低，并且容易出现错误。 </p>
<p>asyncOperation1(function(result1) { </p>
<p>  asyncOperation2(result1, function(result2) { </p>
<p>    asyncOperation3(result2, function(result3) { </p>
<p>      &#x2F;&#x2F; 更多的嵌套… </p>
<p>    }); </p>
<p>  }); </p>
<p>}); </p>
<p>在这个示例中，每个异步操作都依赖于前一个操作的结果，并且需要在前一个操作完成后才能执行。这导致了多层嵌套的回调函数，使得代码难以阅读和理解。 </p>
<p>为了解决回调地狱问题，出现了 Promise、async&#x2F;await 等解决方案，它们使得异步代码更加易于编写和理解，并且消除了多层嵌套的问题。 </p>
<p>注意在forEach里面，由于callback是并行执行的，里面不能加async，否则无法正常执行。合理使用filter、map、reduce配合来实现功能，或者直接用for。 </p>
<p>一、Promise： </p>
<p>Promise 是异步编程的一种解决方案，可以理解成尚未得到但是未来会有的值的占位符，是异步计算结果的一种保证 - 它在未来的某时会生成一个值。 任务完成，分执行成功和执行失败两种情况。 Promise 是构造器函数，需要通过 new 关键字来创建。 构造器参数是一个函数，该函数有两个参数 - resolve 和 reject。 通过它们来判断 promise 的执行结果。 用法如下： </p>
<p>const myPromise &#x3D; new Promise((resolve, reject) &#x3D;&gt; {}); </p>
<p>Promise 有三个状态：pending、fulfilled 和 rejected。 上一个挑战里创建的 promise 一直阻塞在 pending 状态里，因为没有调用 promise 的完成方法。 Promise 提供的 resolve 和 reject 参数就是用来结束 promise 的。 Promise 成功时调用 resolve，promise 执行失败时调用 reject， 如下文所述，这些方法需要有一个参数。 </p>
<p>const myPromise &#x3D; new Promise((resolve, reject) &#x3D;&gt; {   if(condition here) {     resolve(“Promise was fulfilled”);   } else {     reject(“Promise was rejected”);   } }); </p>
<p>参数可以是任何格式。promise完成后，可以用then处理。then 方法为 Promise 的最终完成（履行或拒绝）安排回调函数。将执行 onFulfilled 和 onRejected 处理程序之一来处理当前 Promise 的履行或拒绝。当通过resolve 实现promise 时，将调用onFulfilled 处理程序。 </p>
<p>myPromise.then(result &#x3D;&gt; { </p>
<p>}); </p>
<p>promise失败后，reject方法执行时会直接调用catch方法， </p>
<p>myPromise.catch(error &#x3D;&gt; { &#x2F;&#x2F;error是传入reject方法的参数 </p>
<p>}); </p>
<p>Tip：输入输出： </p>
<p>在很多笔试题的ACM模式中，输入输出都需要自己处理。在JS中可以借用promise的特性生成读取函数，输出直接Console.log就好。 </p>
<p>TIP：Axios： </p>
<p>Axios是一个基于promise的网络请求库，作用于node.js和浏览器中(同一套代码可运行)。在服务端它使用原生 node.js http 模块, 而在客户端 (浏览端) 则使用 XMLHttpRequests。 </p>
<p>特性 </p>
<ul>
<li><p>从浏览器创建 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">XMLHttpRequests</a> </p>
</li>
<li><p>从 node.js 创建 <a target="_blank" rel="noopener" href="http://nodejs.org/api/http.html">http</a> 请求 </p>
</li>
<li><p>支持 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a> API </p>
</li>
<li><p>拦截请求和响应 </p>
</li>
<li><p>转换请求和响应数据 </p>
</li>
<li><p>取消请求 </p>
</li>
<li><p>超时处理 </p>
</li>
<li><p>查询参数序列化支持嵌套项处理 </p>
</li>
<li><p>自动将请求体序列化为： </p>
</li>
<li><p>JSON (application&#x2F;json) </p>
</li>
<li><p>Multipart &#x2F; FormData (multipart&#x2F;form-data) </p>
</li>
<li><p>URL encoded form (application&#x2F;x-www-form-urlencoded) </p>
</li>
<li><p>将 HTML Form 转换成 JSON 进行请求 </p>
</li>
<li><p>自动转换JSON数据 </p>
</li>
<li><p>获取浏览器和 node.js 的请求进度，并提供额外的信息（速度、剩余时间） </p>
</li>
<li><p>为 node.js 设置带宽限制 </p>
</li>
<li><p>兼容符合规范的 FormData 和 Blob（包括 node.js） </p>
</li>
<li><p>客户端支持防御<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Cross-site_request_forgery">XSRF</a></p>
</li>
</ul>
<p> </p>
<p>从Axios官网扒用例然后自己封装改进就可以，完成 </p>
<p>二、async&#x2F;await： （Async &#x3D; makes a function return  a promise </p>
<p>Await &#x3D; makes an async function wait for a promise) </p>
<p>这俩关键字一起用，就能用同步的格式顺序写事实上异步的代码。 </p>
<p>在axios的请求里面经常会用，</p>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenjh3061/personalWeb.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/JavaScript/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Joho Chen">
      <meta itemprop="description" content="个人记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="joho world">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/JavaScript/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-08-30 16:42:14 / 修改时间：16:43:37" itemprop="dateCreated datePublished" datetime="2024-08-30T16:42:14+08:00">2024-08-30</time>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>✅ 对象 </p>
<ul>
<li><p>概念 </p>
</li>
<li><p>this </p>
</li>
<li><p>原型链和继承 </p>
</li>
<li><p>常用对象 </p>
<ul>
<li><p>数字 Number </p>
</li>
<li><p>字符串 String 对象 </p>
</li>
<li><p>日期 Date 对象 </p>
</li>
<li><p>数组 Array </p>
</li>
<li><p>布尔 Boolean </p>
</li>
<li><p>算数 Math</p>
</li>
</ul>
<p> 
      </p>
</li>
<li><p>自定义对象</p>
</li>
</ul>
<p>对象： </p>
<p>Object，和arrays类似，区别在于对象用properties访问，也可以使用数字作为属性。 </p>
<p>Const cat &#x3D;{ </p>
<p>“name”:”Whiskers”, </p>
<p>“legs”:4,”tails”:1, </p>
<p>“enemies”:[“Water”,”Dogs”] </p>
<p>}; </p>
<p>访问对象属性时可以用 .(点号) ，也可以用方括号，比如上面的constcat[“name”]就是Whiskers。 </p>
<p>还有一种方法是借用变量来访问， </p>
<p>Const myDog &#x3D;”Hunter”; const myBreed &#x3D;dogs[myDog];console.log(myBreed); </p>
<p>也可以用点号和括号表达法来新建属性，直接取个名字：ourDog.bark &#x3D;”bow-wow”; </p>
<p>delete关键字用于删除对象的属性。可以用.hasOwnProperty()方法判定一个对象是否具有一个属性，返回true或false。.freeze方法冻结对象，不能添加属性。 </p>
<p>对象的彻底冻结： </p>
<ol>
<li><p>var constantize &#x3D; (obj) &#x3D;&gt; { </p>
</li>
<li><p>  Object.freeze(obj); </p>
</li>
<li><p>  Object.keys(obj).forEach( (key, i) &#x3D;&gt; { </p>
</li>
<li><p>    if ( typeof obj[key] &#x3D;&#x3D;&#x3D; ‘object’ ) { </p>
</li>
<li><p>      constantize( obj[key] ); </p>
</li>
<li><p>    } </p>
</li>
<li><p>  }); </p>
</li>
<li><p>};</p>
</li>
</ol>
<p> </p>
<p>这里Object.keys()方法可以传入一个对象作为参数，生成包含对象所有键的数组。 </p>
<p>验证对象是否从这个构造函数创建：instanceof()，返回布尔值（myHouse instanceof House） </p>
<p>如果一个对象的每个实例都要一个公用的属性值，比如狗对象每个都定义为四条腿，可以用原型属性 </p>
<p>函数也有原型对象。 </p>
<p>prototype：Bird.prototype.numLegs &#x3D; 2;   原型属性可以写多个属性甚至方法。 </p>
<p>检查一个实例的构造方法可以用constructor属性，console.log(duck.constructor &#x3D;&#x3D;&#x3D; Bird);  </p>
<p>手动设置原型对象会自动重置constructor属性，记得加上。 </p>
<ul>
<li>顶层对象：</li>
</ul>
<p> </p>
<p>    在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 </p>
<p>      ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。 </p>
<ol>
<li><p>var a &#x3D; 1; </p>
</li>
<li><p>&#x2F;&#x2F; 如果在 Node 的 REPL 环境，可以写成 global.a </p>
</li>
<li><p>&#x2F;&#x2F; 或者采用通用方法，写成 this.a </p>
</li>
<li><p>window.a &#x2F;&#x2F; 1 </p>
</li>
<li><p>let b &#x3D; 1; </p>
</li>
<li><p>window.b &#x2F;&#x2F; undefined</p>
</li>
</ol>
<p> </p>
<p>上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。 </p>
<ul>
<li>globalThis对象：</li>
</ul>
<p> </p>
<p>    JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。 </p>
<p>浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。 </p>
<p>浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。 </p>
<p>Node 里面，顶层对象是global，但其他环境都不支持。 </p>
<p>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。 </p>
<p>    全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。 </p>
<p>    函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。 </p>
<p>    不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么eval、new Function这些方法都可能无法使用。 </p>
<p>综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。 </p>
<ol start="9">
<li><p>&#x2F;&#x2F; 方法一 </p>
</li>
<li><p>(typeof window!&#x3D;&#x3D; ‘undefined’ </p>
</li>
<li><p>   ? window </p>
</li>
<li><p>   : (typeof process &#x3D;&#x3D;&#x3D; ‘object’ &amp;&amp; </p>
</li>
<li><p>      typeof require&#x3D;&#x3D;&#x3D; ‘function’ &amp;&amp; </p>
</li>
<li><p>      typeof global &#x3D;&#x3D;&#x3D; ‘object’) </p>
</li>
<li><p>     ? global </p>
</li>
<li><p>     : this); </p>
</li>
<li><p>&#x2F;&#x2F; 方法二 </p>
</li>
<li><p>var getGlobal &#x3D; function () { </p>
</li>
<li><p>  if (typeof self !&#x3D;&#x3D; ‘undefined’) { return self; } </p>
</li>
<li><p>  if (typeof window!&#x3D;&#x3D; ‘undefined’) { return window; } </p>
</li>
<li><p>  if (typeof global !&#x3D;&#x3D; ‘undefined’) { return global; } </p>
</li>
<li><p>  throw new Error(‘unable to locate global object’); </p>
</li>
<li><p>};</p>
</li>
</ol>
<p> </p>
<p>ES2020 在语言标准的层面，引入globalThis作为顶层对象。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。 </p>
<p>垫片库global-this模拟了这个提案，可以在所有环境拿到globalThis。 </p>
<p>Tip：链判断 </p>
<p>读取对象内部某属性的时候往往需要判断是否存在，这里可以用原型链。JavaScript 中所有的对象（除了少数例外）都有自己的 prototype。 而且，对象的 prototype 本身也是一个对象。 </p>
<p>hasOwnProperty 是定义在 Object.prototype 上的一个方法，尽管在 Bird.prototype 和 duck上并没有定义该方法，但是我们依然可以在这两个对象上访问到。 这就是 prototype 链的一个例子。 在这个prototype 链中，Bird 是 duck 的 supertype，而 duck 是 subtype。 Object 则是 Bird 和 duck 实例共同的 supertype。 Object 是 JavaScript 中所有对象的 supertype，也就是原型链的最顶层。 因此，所有对象都可以访问 hasOwnProperty 方法。<br>![[Pasted image 20240830164257.png]]</p>
<p>Tip：继承 </p>
<p>公共属性多的，可以抽象一个超类(supertype)<br>![[Pasted image 20240830164316.png]]<br>然后给子类型设置prototype，<br>![[Pasted image 20240830164329.png]]</p>
<p>当一个对象从另一个对象那里继承了其 prototype 时，那它也继承了父类的 constructor 属性。 </p>
<p>可以手动将 Bird 的构造函数属性设置为 Bird 对象，也可以用这种方法定义别的方法： </p>
<p>Bird.prototype.constructor &#x3D; Bird; </p>
<p>duck.constructor </p>
<p>继承可以重写。 </p>
<p>闭包： </p>
<p>用闭包可以保护对象内属性不被外部修改，比如在构造函数中创建变量，把变量限定在构造函数中，而不是全局可用。 </p>
<p>类： </p>
<p>ES6中引入了关键字class， </p>
<p>定义：class A {  </p>
<p>              #abc;  </p>
<p>              constructor() { </p>
<p>                    this.#abc &#x3D; 1;      &#x2F;&#x2F;#表示私有字段  </p>
<p>            } </p>
<p>         } </p>
<p>构造方法、getter和setter、都可以参考Java</p>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenjh3061/personalWeb.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/JavaScript/%E5%87%BD%E6%95%B0%E3%80%81%E9%A1%BA%E5%BA%8F%E3%80%81%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Joho Chen">
      <meta itemprop="description" content="个人记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="joho world">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/JavaScript/%E5%87%BD%E6%95%B0%E3%80%81%E9%A1%BA%E5%BA%8F%E3%80%81%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-08-30 16:38:41 / 修改时间：16:41:52" itemprop="dateCreated datePublished" datetime="2024-08-30T16:38:41+08:00">2024-08-30</time>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>✅ 函数 </p>
<ul>
<li><p>⭐️ 概念 </p>
</li>
<li><p>⭐️ 自定义函数 </p>
</li>
<li><p>调用方式 </p>
<ul>
<li><p>⭐️ 全局调用 </p>
</li>
<li><p>构造函数调用 </p>
</li>
<li><p>⭐️ 函数方法调用 </p>
</li>
<li><p>apply </p>
</li>
<li><p>call</p>
</li>
</ul>
<p> 
      </p>
</li>
<li><p>✅❗ 闭包</p>
</li>
</ul>
<p>一、函数介绍 </p>
<p>JS中用函数编写可重用代码，举例： </p>
<p>Function functionName(){ </p>
<p>console.log(“Hello World”); </p>
<p>} </p>
<p>  还有： </p>
<p>var myConcat &#x3D; function(arr1, arr2) { </p>
<p>  return arr1.concat(arr2); </p>
<p>}; </p>
<p>console.log(myConcat([1, 2], [3, 4, 5])); </p>
<p>可以通过函数名加上后面的小括号来调用（invoke）这个函数，就像这样： functionName(); 每次调用函数时，它都会在控制台上打印消息 Hello World。 每次调用函数时，大括号之间的所有代码都将被执行。 </p>
<p>如果有参数，记得在括号中声明。 </p>
<p>使用return可以添加返回值，返回值可以是undefined。 </p>
<p>除了上述写法，ES6允许箭头匿名函数： </p>
<p>const increment &#x3D; (number, value) &#x3D;&gt; { number + value }; </p>
<p>ES6还添加了rest操作符（rest参数）帮助创建更加灵活的函数，如:</p>
<p>![[Pasted image 20240830164037.png]]</p>
<p>Tip：函数长度 </p>
<p>函数的长度就是必须输入的形参的个数，也就是第一个带默认值的参数前的参数个数，注意不算剩余参数 </p>
<p>![[Pasted image 20240830164104.png]]</p>
<p>注意这里 123[‘toString’].length 是用了点符号访问(或者叫“对象属性访问”)的方法调用函数，123是一个数字字面量，这里就是访问数字123的toString方法，再算这个函数的长度。 </p>
<p>函数原型 </p>
<p>prototype也有，在new运算符调用构造函数的时候起作用，用法类似对象。 </p>
<p>caller属性 </p>
<p>判断函数调用情况，在哪里调用，顶层代码就返回null，否则返回调用该函数的当前函数的Function对象的引用。 </p>
<p>Call() 方法 </p>
<p>可以用来调用所有者对象作为参数的方法。Apply()方法类似 </p>
<p>![[Pasted image 20240830164116.png]]</p>
<p>二、全局&#x2F;局部作用域和函数 </p>
<p>    在 JavaScript 中，作用域涉及到变量的作用范围。 在函数外定义的变量具有 全局 作用域。 这意味着，具有全局作用域的变量可以在代码的任何地方被调用。 </p>
<p>    未使用 let 或 const 关键字声明的变量会在 global 范围内自动创建。 当在代码其他地方无意间定义了一个变量，刚好变量名与全局变量相同，这时会产生意想不到的后果。 你应该总是用 let 或 const 声明你的变量。 </p>
<p>    一个函数内可能有相同名称的局部和全局变量，此时局部变量会优先于全局变量。 </p>
<p>Tip：函数参数 </p>
<p>parameters和arguments都是参数的意思，parameters 是函数定义中列出的名称，用作调用函数时所传递的值的占位符。再看 arguments，arguments 是调用函数时提供给函数的实际值。非箭头函数中的arguments对象包涵传递给函数的所有参数，可以输出。 </p>
<p>![[Pasted image 20240830164130.png]]</p>
<p>rest参数和arguments对象都允许函数灵活处理多个输入，但更推荐rest，提高代码可读性 </p>
<p>函数式编程： </p>
<p>1）功能独立——不依赖于程序的状态（比如可能发生变化的全局变量）； </p>
<p>2）纯函数——同一个输入永远能得到同一个输出； </p>
<p>3）有限的副作用——可以严格地限制函数外部对状态的更改。 </p>
<p>三、选择语句 </p>
<p>if语句，Switch，同java。巧用Switch替换简单而冗杂的if，也可以用map优化 </p>
<p>??是控制合并运算符，如果变量是null或者undefined，才会返回右边的值，可以代替一句if </p>
<p>!!双重否定能把一个值转为布尔值，0、undefined、null会变成false，其他是true </p>
<p>![[Pasted image 20240830164151.png]]</p>
<p>四、异常处理语句 </p>
<p>1、throw </p>
<p>Function fun(x, y){ </p>
<p>If(y&#x3D;&#x3D;0){ </p>
<p>Throw new Error(“除数不为零”); </p>
<p>} </p>
<p>} </p>
<p>2、try…catch…finally</p>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenjh3061/personalWeb.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/JavaScript/JS%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Joho Chen">
      <meta itemprop="description" content="个人记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="joho world">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/JavaScript/JS%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-08-30 16:35:00 / 修改时间：16:39:59" itemprop="dateCreated datePublished" datetime="2024-08-30T16:35:00+08:00">2024-08-30</time>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/es6-3rd/spilt.1.docs-intro.md">1. ECMAScript 6 简介 - ECMAScript 和 JavaScript 的关系 - 《阮一峰 ECMAScript 6 (ES6) 标准入门教程 第三版》 - 书栈网 · BookStack</a> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 JScript 和 ActionScript）。日常场合，这两个词是可以互换的。 </span><br><span class="line"></span><br><span class="line">在浏览器环境，JS就是ECMAScript + WebApis(BOM + DOM) </span><br><span class="line"></span><br><span class="line">在 node 环境中，JavaScript = ECMAScript + NodeApis(fs,net等) </span><br><span class="line"></span><br><span class="line">js引擎原理： [https://mp.weixin.qq.com/s/3rQtf5d8qCKeQslbtn9vQQ](https://mp.weixin.qq.com/s/3rQtf5d8qCKeQslbtn9vQQ)</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript</a> </p>
<p>JS是具有函数优先的轻量级，解释型或即时编译型的编程语言。是一门完备的动态编程语言，应用于HTML时为网站提供动态交互特性。 </p>
<p>开发者基于JS核心编写了大量实用工具，包括浏览器API，第三方的API和框架与库。 </p>
<p>在项目中用<code>&lt;script&gt;</code>标签引入<br>![[Pasted image 20240830163656.png]]</p>
<p>一、直接量 </p>
<p>数字、字符串等直接显露出来的东西，就叫直接量 </p>
<p>二、变量 </p>
<p>var自动定义变量类型：var a &#x3D; “hello” </p>
<p>let自动定义变量类型（ES6新增）： </p>
<p>不同： </p>
<ul>
<li>作用域：</li>
</ul>
<p> </p>
<p>    var 声明的变量存在函数级作用域，而不是块级作用域。在函数内部声明的变量在整个函数内部都是可见的。 </p>
<p>    let 声明的变量存在块级作用域，例如在 if 语句或循环中声明的变量只在该块内部可见（for循环就比较适合用let，注意循环括号里面和循环体里面的let不是一个作用域）。 </p>
<ul>
<li>变量提升：</li>
</ul>
<p> </p>
<p>    使用 var 声明的变量存在变量提升，即变量可以在声明之前被访问，但其值为 undefined。这是因为在执行代码之前，JS引擎会将变量声明提升到其作用域的顶部。注意赋值不会提升，只有声明提升。 </p>
<p>    使用 let 声明的变量也存在提升，但不会被初始化，直到遇到声明语句。 </p>
<p>console.log(a); &#x2F;&#x2F; 输出 undefined </p>
<p>var a &#x3D; 10; </p>
<p>console.log(b); &#x2F;&#x2F; 报错，暂时性死区（Temporal Dead Zone，TDZ） </p>
<p>let b &#x3D; 20; </p>
<p>暂时性死区：ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 </p>
<ul>
<li>重复声明：</li>
</ul>
<p> </p>
<p>    使用 var 可以重复声明同一个变量，而不会报错。 </p>
<p>    使用 let 在同一作用域内重复声明同一个变量会导致语法错误。 </p>
<p>var x &#x3D; 10; </p>
<p>var x &#x3D; 20; &#x2F;&#x2F; 合法，不会报错 </p>
<p>let y &#x3D; 30; </p>
<p>let y &#x3D; 40; &#x2F;&#x2F; 报错，重复声明 </p>
<ul>
<li>全局对象属性：</li>
</ul>
<p> </p>
<p>    使用 var 声明的变量会成为全局对象的属性。 </p>
<p>    使用 let 声明的变量不会成为全局对象的属性。 </p>
<p>var globalVar &#x3D; 50; </p>
<p>let localVar &#x3D; 60; </p>
<p>console.log(window.globalVar); &#x2F;&#x2F; 输出 50 </p>
<p>console.log(window.localVar); &#x2F;&#x2F; 输出 undefined </p>
<p>总体而言，在现代JavaScript开发中，推荐使用 let 替代 var，因为 let 提供了更好的作用域规则和避免了一些 var 的问题。 </p>
<p>tip：块级作用域（一定要加大括号） </p>
<p>ES5只有全局作用域和函数作用域，没有块级作用域，不够合理，可能会导致内层变量覆盖外层变量，或者用来技术的循环变量泄露为全局变量。例子： </p>
<ol>
<li><p>var tmp &#x3D; new Date(); </p>
</li>
<li><p>function f() { </p>
</li>
<li><p>  console.log(tmp); </p>
</li>
<li><p>  if (false) { </p>
</li>
<li><p>    var tmp &#x3D; ‘hello world’;&#x2F;&#x2F;变量提升 </p>
</li>
<li><p>  } </p>
</li>
<li><p>} </p>
</li>
<li><p>f(); &#x2F;&#x2F; undefined</p>
</li>
</ol>
<p> </p>
<p>ES6引入了let，实际上也是借用let封闭作用域的特点，实现块级作用域的功能。ES6也允许块级作用域的嵌套。同时相对于ES5，允许了在块级作用域中定义函数，函数影响范围也在块内。 </p>
<p>不过要注意5和6环境的巨大差异和函数的复杂性，尽量避免在块级作用域声明函数，要的话也只写函数表达式就行，不用函数声明语句。 </p>
<ol>
<li><p>&#x2F;&#x2F; 块级作用域内部，优先使用函数表达式 </p>
</li>
<li><p>{ </p>
</li>
<li><p>  let a &#x3D; ‘secret’; </p>
</li>
<li><p>  let f &#x3D; function () { </p>
</li>
<li><p>    return a; </p>
</li>
<li><p>  }; </p>
</li>
<li><p>}</p>
</li>
</ol>
<p> </p>
<p>tip：数据类型 </p>
<p>在JavaScript中，数据可分为两类，分别为原生数据类型（primitive type）和对象数据类型（object type）。 </p>
<p>原生数据类型包括数字、字符串、布尔值（不用单独声明，let var都行）、符号类型，还有两个特殊的类型：null和undefined。 </p>
<p>对象数据类型包括对象、数组、函数、日期、正则表达式、Map、Set等 </p>
<p>或者按照值类型和引用类型分，分别有：字符串 String、数组 Number、布尔 Boolean、空值 Null、未定义 Undefined、Symbol。||  对象Object、数组Array、函数function。 </p>
<p>当 JavaScript 中的变量被声明的时候，程序内部会给它一个初始值 undefined。 当你对一个值为 undefined 的变量进行运算操作的时候，算出来的结果将会是 NaN，它的意思是 “Not a Number”。 如果你用 undefined 变量连接一个字符串，你将得到一个 undefined 的 字符串。 </p>
<p>注意undefined派生自null，用&#x3D;&#x3D;比较会给true，null是关键字，undefined是一个挂在在window的全局变量。在需要进行数值类型的转换时，undefined会转换为NaN，无法参与计算；null会转换为0，可以参与计算。 量来保存将来要使用的对象，应该将其初始化为null。这样不仅能将null作为空对象指针的惯例，还有助于区分null和undefined。 </p>
<ul>
<li><p>数据类型转换： </p>
<p>  在变量前面加上！！，变量会变成布尔类型true。 </p>
<p>  ！&#x3D;&#x3D;和！&#x3D;的区别是不完全非等会自动转换类型再比 </p>
</li>
<li><p>数组类型： </p>
<p>  Const ourArray &#x3D;[50,40,30]; ourArray[0]&#x3D;15; </p>
<p>  与字符串不同，const数组可以修改，里面可以存放不同类型数据 </p>
<p>  在 JavaScript 中，使用 const 声明的变量表示常量，它们的值在声明后不能被重新赋值。对于基本数据类型（如数字、字符串、布尔值），const 的行为是符合直觉的，一旦赋值后，就不能再改变该常量的值。 </p>
<p>  然而，对于复合数据类型，如数组和对象，const 并不意味着不能修改数组或对象中的元素或属性。const 仅仅保证变量引用的地址不会改变，而并不阻止对该地址引用的对象进行修改。这是因为 const 保护的是变量（即引用地址），而不是变量所指向的内存中的内容。 </p>
<p>  数组的操作主要是push()[追加在最后]，pop()[返回最后一个]，shift()[返回第一个] </p>
<p>  unshift()[插入到第一个]，splice()[从数组中的任意位置连续删除任意数量的元素，(1,1)]， </p>
<p>  Slice()[提取指定数量数组元素给新数组，配合…默认能复制数组] </p>
<p>  splice可以传入第三个参数，可以是一个或多个元素，添加到数组中（替换）。 </p>
<p>  开始和结束范围的元素会被返回，可以用这个特点复制数组元素。 </p>
<p>  indexOf函数返回元素位置, </p>
<p>  reduce()[接收一个规约函数和一个可选初始值，] </p>
<p>  数组传入一些函数时，如果该函数不能直接接受数组而是要接收一串变量，就要先用spread运算符展开这个数组：<br>  ![[Pasted image 20240830163728.png]]</p>
</li>
</ul>
<p>数组排序： </p>
<p>Nums.sort((a, b) &#x3D;&gt; a-b);从小到大，从大到小就b-a。 </p>
<p>使用 every()，map(), filter(), reduce() 等数组方法替代传统循环，可以使代码更简洁且易于阅读。 </p>
<p>&#x2F;&#x2F; 传统循环 </p>
<p>let sum &#x3D; 0; </p>
<p>for (let i &#x3D; 0; i &lt; numbers.length; i++) { </p>
<p>  sum +&#x3D; numbers[i]; </p>
<p>} </p>
<p>&#x2F;&#x2F; 使用 reduce 方法 </p>
<p>let sumWithReduce &#x3D; numbers.reduce((acc, curr) &#x3D;&gt; acc + curr, 0); </p>
<p>symbol类型： </p>
<p>本质是一种唯一标识符，可用作对象的唯一属性名，保证每个属性的名字独一无二，其他人就不会改写或覆盖设置的属性值。因为本质不是对象，所以不能用new。 </p>
<p> let id1 &#x3D; Symbol(‘id’); </p>
<p> let id2 &#x3D; Symbol(‘id’); </p>
<p> console.log(id1 &#x3D;&#x3D; id2);  &#x2F;&#x2F;false </p>
<p>另一特点是隐藏性，只有Object.getOwnPropertySymbols方法才能访问，Object.getOwnPropertySymbols 方法会返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。 </p>
<p>Symbol 值的实例属性description，直接返回 Symbol 值的描述。</p>
<p>![[Pasted image 20240830163800.png]]</p>
<p>三、不变量 </p>
<p>Const： </p>
<p>JS中，const声明一个只读常量，声明之后立刻要初始化，不能留到以后赋值。 </p>
<p>作用于只在块级作用域。同样不提升、存在暂时性死区。 </p>
<p>本质上const是变量指向的内存地址所保存的数据不得改动，但是对于对象和数组这样的复合类型数据，变量指向的内存地址保存的只是一个指向实际数据的指针，指针指向的东西不是不可变的，这种情况要小心。如果真想把整个对象锁住，用Object.freeze方法。 </p>
<p>字符串： </p>
<p>JavaScript中，字符串String的值是不可变的。更改 myStr 的唯一方法是为其分配一个新值，如下所示：let myStr &#x3D; “Bob”;myStr &#x3D; “Job”; </p>
<p>字符串长度：.length </p>
<p>注意可以使用模板字面量创建字符串：借助循环能大量输出句子 </p>
<p>const person &#x3D; {   name: “Zodiac Hasbro”,   age: 56 }; </p>
<p>const greeting &#x3D; <code>Hello, my name is $&#123;person.name&#125;! I am $&#123;person.age&#125; years old.</code>; </p>
<p>字符串方法： </p>
<p>slice、substring、substr都是截取子串 </p>
<p>trim去除两端空白，cplit拆分，fromCharCode从字符码转字符 </p>
<p>charCodeAt获取字符Unicode，concat链接，用+容易出错 </p>
<p>let rawString &#x3D; String.raw<code>C:\Development\project</code>;不会动反斜杠 </p>
<p>function titleCase(str) { </p>
<p>  return str </p>
<p>    .toLowerCase() &#x2F;&#x2F; 将整个字符串转换为小写 </p>
<p>    .split(“ “)    &#x2F;&#x2F; 将字符串按照空格分割成数组 </p>
<p>    .map(val &#x3D;&gt; val.replace(val.charAt(0), val.charAt(0).toUpperCase())) &#x2F;&#x2F; 将每个单词的首字母大写 </p>
<p>    .join(“ “);    &#x2F;&#x2F; 将数组重新拼接成一个字符串，并用空格连接 </p>
<p>} </p>
<p>四、运算 </p>
<p>加减乘除++–求余简写+&#x3D;转义字符都一样，只是注意字符串之间的+用法类同java </p>
<p>相等运算符&#x3D;&#x3D;（不管具体数据类型），全等运算符&#x3D;&#x3D;&#x3D;（数据类型也要一样） </p>
<p>严格不等！&#x3D;&#x3D;（和全等相反） </p>
<p>void 操作符用于抑制副作用并返回 undefined。它常被用于：1. 抑制函数调用返回值；2. 消除表达式副作用；3. 获取未定义值。它不会影响表达式的求值顺序或强制转换表达式类型。</p>
<p>![[Pasted image 20240830163832.png]]</p>
<p>五、关于es5和es6<a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/es6-3rd/spilt.5.docs-intro.md">ECMAScript 6 简介 - Babel 转码器 - 《阮一峰 ECMAScript 6 (ES6) 标准入门教程 第三版》</a>  </p>
<p>两种不同的标准，可以使用Babel转码器将 ES6 代码转为 ES5 代码，从而在老版本的浏览器执行。 </p>
<p>六、随机数</p>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenjh3061/personalWeb.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CSS/CSS3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Joho Chen">
      <meta itemprop="description" content="个人记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="joho world">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CSS/CSS3/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-08-30 16:33:55 / 修改时间：16:33:59" itemprop="dateCreated datePublished" datetime="2024-08-30T16:33:55+08:00">2024-08-30</time>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>331</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><p>CSS3 </p>
<ul>
<li><p>⭐️ 响应式布局 </p>
<ul>
<li><p>媒体查询 </p>
<ul>
<li>多栏布局media screen</li>
</ul>
<p>  
      </p>
</li>
<li><p>弹性布局Flex  </p>
</li>
<li><p>Grid 布局 </p>
</li>
<li><p>瀑布流</p>
</li>
</ul>
<p> 
      </p>
</li>
<li><p>动画 </p>
<p>  自定义动画animate @keyform </p>
</li>
<li><p>过渡 </p>
<p>  transition，可实现动画 </p>
</li>
<li><p>渐变 </p>
<p>  : linear-gradient , radial-gradien </p>
</li>
<li><p>背景 </p>
<p>  background-size，background-origin，background-clip </p>
</li>
<li><p>边框 </p>
<p>  圆角：border-radius  边框阴影：box-shadow </p>
</li>
<li><p>圆角 </p>
</li>
<li><p>字体 </p>
<p>  font-face </p>
</li>
<li><p>2D &#x2F; 3D 转换： </p>
<ul>
<li>transform： translate(x,y) rotate(x,y) skew(x,y) scale(x,y)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p> </p>
<p>颜色：新增RGBA、HSLA模式 </p>
<p>文字阴影：text-shadow </p>
<p>盒子模型：box-sizing</p>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenjh3061/personalWeb.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CSS/%E5%B0%8F%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Joho Chen">
      <meta itemprop="description" content="个人记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="joho world">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CSS/%E5%B0%8F%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-08-30 16:33:55 / 修改时间：16:34:50" itemprop="dateCreated datePublished" datetime="2024-08-30T16:33:55+08:00">2024-08-30</time>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>586</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1、阴影效果 </p>
<p>h1 { </p>
<p>  font-size: 60px; </p>
<p>  font-family: ‘Montserrat’; </p>
<p>} </p>
<p>h1::before { </p>
<p>  content: ‘Hello World!’; </p>
<p>  position: absolute; </p>
<p>  color: #000; </p>
<p>  transform: translate(-60px,10px) scaleY(0.5) skew(50deg); </p>
<p>  z-index: -1; </p>
<p>  filter: blur(5px); </p>
<p>  mask-image: linear-gradient(transparent,#000); </p>
<p>} </p>
<p>before用来在h1元素之前插入一段内容， </p>
<p>content: ‘Hello World!’; 伪元素的内容是 ‘Hello World!’。 </p>
<p>position: absolute; 使伪元素绝对定位，相对于最近的定位祖先（如果没有，则相对于初始包含块）。 </p>
<p>color: #000; 伪元素的文本颜色为黑色。 </p>
<p>transform: translate(-60px, 10px) scaleY(0.5) skew(50deg); 对伪元素进行平移、缩放和倾斜变换。 </p>
<p>z-index: -1; 将伪元素的堆叠顺序设置为 -1，使其在 h1 元素后面显示。 </p>
<p>filter: blur(5px); 应用 5 像素的模糊效果。 </p>
<p>mask-image: linear-gradient(transparent, #000); 使用线性渐变作为遮罩图像，从透明过渡到黑色。</p>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenjh3061/personalWeb.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CSS/%E6%96%87%E6%A1%A3%E6%B5%81+%E5%85%83%E7%B4%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Joho Chen">
      <meta itemprop="description" content="个人记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="joho world">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CSS/%E6%96%87%E6%A1%A3%E6%B5%81+%E5%85%83%E7%B4%A0/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-08-30 16:33:55 / 修改时间：16:34:14" itemprop="dateCreated datePublished" datetime="2024-08-30T16:33:55+08:00">2024-08-30</time>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>30</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><p>⭐️ 文档流 </p>
<ul>
<li><p>标准流 </p>
</li>
<li><p>浮动流 </p>
</li>
<li><p>定位流</p>
</li>
</ul>
<p> 
      </p>
</li>
<li><p>⭐️ 内联元素 &#x2F; 块状元素</p>
</li>
</ul>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Joho Chen</p>
  <div class="site-description" itemprop="description">个人记录</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">74</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/chenjh3061" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chenjh3061" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://music.163.com/#" title="https:&#x2F;&#x2F;music.163.com&#x2F;#" rel="noopener" target="_blank">Title</a>
        </li>
    </ul>
  </div>

      </div>
      
      <script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
      <script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
      <div class="widget-wrap">
          <h5 class="widget-title">标签云</h5>
          <div id="myCanvasContainer" class="widget tagcloud">
              <canvas width="250" height="250" id="resCanvas" style="width:100%">
                  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E6%94%B6%E9%9B%86/" rel="tag">代码收集</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AC%94%E8%AF%95%E9%A2%98/" rel="tag">笔试题</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E7%BB%8F/" rel="tag">面经</a><span class="tag-list-count">1</span></li></ul>
              </canvas>
          </div>
      </div>
      
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Joho Chen</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">67k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:01</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>
# 网站运行时间
runtime:
   enable: true
   create_time: "04/15/2022 13:18:00"
   start: 2022-04-15 13:13:00 +0800
   mobile: false

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

    </div>
</body>
</html>
