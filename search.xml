<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>//hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.<br><a href="https://www.zhihu.com/column/c_1502937018040057858">https://www.zhihu.com/column/c_1502937018040057858</a></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new (post) <span class="string">&quot;My New Post&quot;</span>    (post可写可不写)  </span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server / hexo s</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<p>常见命令：<br>hexo new “postName”      # 新建文章<br>hexo new page “pageName” # 新建页面<br>hexo generate            # 生成静态页面至public目录<br>hexo server              # 开启预览访问端口（默认端口4000，’ctrl + c’关闭server）<br>hexo deploy              # 部署到GitHub<br>hexo help                # 查看帮助<br>hexo version             # 查看Hexo的版本<br>缩写命令：<br>hexo n &#x3D;&#x3D; hexo new<br>hexo g &#x3D;&#x3D; hexo generate<br>hexo s &#x3D;&#x3D; hexo server<br>hexo d &#x3D;&#x3D; hexo deploy<br>组合命令：<br>hexo s -g   # 生成并本地预览<br>hexo d -g   # 生成并上传</p>
]]></content>
  </entry>
  <entry>
    <title>计算机网络总纲</title>
    <url>//%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BA%B2/</url>
    <content><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><h3 id="计算机网络的概念、组成、分类"><a href="#计算机网络的概念、组成、分类" class="headerlink" title="计算机网络的概念、组成、分类"></a>计算机网络的概念、组成、分类</h3><h3 id="体系结构-与-分层结构"><a href="#体系结构-与-分层结构" class="headerlink" title="体系结构 与 分层结构"></a>体系结构 与 分层结构</h3><h3 id="ISO-OSI参考模型和TCP-IP模型"><a href="#ISO-OSI参考模型和TCP-IP模型" class="headerlink" title="ISO&#x2F;OSI参考模型和TCP&#x2F;IP模型"></a>ISO&#x2F;OSI参考模型和TCP&#x2F;IP模型</h3><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络总纲</title>
    <url>//%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%80%BB%E7%BA%B2/</url>
    <content><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h2 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h2><h2 id="数据的表示和运算"><a href="#数据的表示和运算" class="headerlink" title="数据的表示和运算"></a>数据的表示和运算</h2><h2 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h2><h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><h2 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h2><h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><h2 id="输入-输出系统"><a href="#输入-输出系统" class="headerlink" title="输入&#x2F;输出系统"></a>输入&#x2F;输出系统</h2>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构总纲</title>
    <url>//%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><h3 id="数据结构（三要素）"><a href="#数据结构（三要素）" class="headerlink" title="数据结构（三要素）"></a>数据结构（三要素）</h3><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><h5 id="线性结构：线性表、栈、队列"><a href="#线性结构：线性表、栈、队列" class="headerlink" title="线性结构：线性表、栈、队列"></a>线性结构：线性表、栈、队列</h5><h5 id="树、图、集合"><a href="#树、图、集合" class="headerlink" title="树、图、集合"></a>树、图、集合</h5><h4 id="存储结构（物理结构）"><a href="#存储结构（物理结构）" class="headerlink" title="存储结构（物理结构）"></a>存储结构（物理结构）</h4><h4 id="数据的运算"><a href="#数据的运算" class="headerlink" title="数据的运算"></a>数据的运算</h4><h3 id="五个特征"><a href="#五个特征" class="headerlink" title="五个特征"></a>五个特征</h3><h4 id="算法定义"><a href="#算法定义" class="headerlink" title="算法定义"></a>算法定义</h4><h4 id="五个特征：有穷性、确定性、可行性、输入、输出"><a href="#五个特征：有穷性、确定性、可行性、输入、输出" class="headerlink" title="五个特征：有穷性、确定性、可行性、输入、输出"></a>五个特征：有穷性、确定性、可行性、输入、输出</h4><h4 id="效率的度量"><a href="#效率的度量" class="headerlink" title="效率的度量"></a>效率的度量</h4><h5 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h5><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><h4 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h4><h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><h4 id="单链表、双链表、循环链表（指针实现）"><a href="#单链表、双链表、循环链表（指针实现）" class="headerlink" title="单链表、双链表、循环链表（指针实现）"></a>单链表、双链表、循环链表（指针实现）</h4><h4 id="静态链表（数组实现）"><a href="#静态链表（数组实现）" class="headerlink" title="静态链表（数组实现）"></a>静态链表（数组实现）</h4><h2 id="栈、队列和数组"><a href="#栈、队列和数组" class="headerlink" title="栈、队列和数组"></a>栈、队列和数组</h2><h3 id="操作受限"><a href="#操作受限" class="headerlink" title="操作受限"></a>操作受限</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><h5 id="顺序栈、链共享栈"><a href="#顺序栈、链共享栈" class="headerlink" title="顺序栈、链共享栈"></a>顺序栈、链共享栈</h5><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><h5 id="循环队列、链式队列、双端队列"><a href="#循环队列、链式队列、双端队列" class="headerlink" title="循环队列、链式队列、双端队列"></a>循环队列、链式队列、双端队列</h5><h3 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h3><h4 id="数组（重点易错，回看）"><a href="#数组（重点易错，回看）" class="headerlink" title="数组（重点易错，回看）"></a><strong>数组</strong>（重点易错，回看）</h4><h5 id="一维数组、多维数组（压缩存储、稀疏矩阵）"><a href="#一维数组、多维数组（压缩存储、稀疏矩阵）" class="headerlink" title="一维数组、多维数组（压缩存储、稀疏矩阵）"></a>一维数组、多维数组（压缩存储、稀疏矩阵）</h5><h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><h3 id="基本概念：主串、子串、串长"><a href="#基本概念：主串、子串、串长" class="headerlink" title="基本概念：主串、子串、串长"></a>基本概念：主串、子串、串长</h3><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><h4 id="定长顺序存储"><a href="#定长顺序存储" class="headerlink" title="定长顺序存储"></a>定长顺序存储</h4><h4 id="堆分配存储"><a href="#堆分配存储" class="headerlink" title="堆分配存储"></a>堆分配存储</h4><h4 id="块链存储"><a href="#块链存储" class="headerlink" title="块链存储"></a>块链存储</h4><h3 id="模式匹配算法"><a href="#模式匹配算法" class="headerlink" title="模式匹配算法"></a>模式匹配算法</h3><h4 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h4><h4 id="KMP：部分匹配值表、next数组、next函数推理过程"><a href="#KMP：部分匹配值表、next数组、next函数推理过程" class="headerlink" title="KMP：部分匹配值表、next数组、next函数推理过程"></a>KMP：部分匹配值表、next数组、next函数推理过程</h4><h4 id="KMP算法的进一步改进"><a href="#KMP算法的进一步改进" class="headerlink" title="KMP算法的进一步改进"></a>KMP算法的进一步改进</h4><h2 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="概念、定义、存储结构"><a href="#概念、定义、存储结构" class="headerlink" title="概念、定义、存储结构"></a>概念、定义、存储结构</h4><h4 id="操作：三种遍历、线索二叉树"><a href="#操作：三种遍历、线索二叉树" class="headerlink" title="操作：三种遍历、线索二叉树"></a>操作：三种遍历、线索二叉树</h4><h4 id="应用：并查集、哈夫曼树"><a href="#应用：并查集、哈夫曼树" class="headerlink" title="应用：并查集、哈夫曼树"></a>应用：并查集、哈夫曼树</h4><h3 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h3><h4 id="概念：定义、存储结构"><a href="#概念：定义、存储结构" class="headerlink" title="概念：定义、存储结构"></a>概念：定义、存储结构</h4><h4 id="操作：与二叉树的转换、遍历"><a href="#操作：与二叉树的转换、遍历" class="headerlink" title="操作：与二叉树的转换、遍历"></a>操作：与二叉树的转换、遍历</h4><h4 id="应用：并查集"><a href="#应用：并查集" class="headerlink" title="应用：并查集"></a>应用：并查集</h4><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构（一）——绪论&amp;数组、链表、字符串</title>
    <url>//%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="0、引"><a href="#0、引" class="headerlink" title="0、引"></a>0、引</h1><p>这里记录一些题目收集情况，主要逻辑来自 <a href="https://www.programmercarl.com/">代码随想录</a></p>
<h1 id="·数组"><a href="#·数组" class="headerlink" title="·数组"></a>·数组</h1><p>经常结合双指针法</p>
<h2 id="典型题目："><a href="#典型题目：" class="headerlink" title="典型题目："></a>典型题目：</h2><table>
<thead>
<tr>
<th>题目</th>
<th>力扣链接</th>
<th>解法</th>
<th>评价</th>
</tr>
</thead>
<tbody><tr>
<td>移除元素</td>
<td><a href="https://leetcode.cn/problems/remove-element/description/">移除元素</a></td>
<td>推荐双指针</td>
<td>触类旁通</td>
</tr>
<tr>
<td>有序数组平方</td>
<td><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">有序数组平方</a></td>
<td>双指针</td>
<td></td>
</tr>
<tr>
<td>螺旋矩阵</td>
<td><a href="https://leetcode.cn/problems/spiral-matrix-ii/">螺旋矩阵</a></td>
<td>背代码</td>
<td></td>
</tr>
</tbody></table>
<h1 id="·链表"><a href="#·链表" class="headerlink" title="·链表"></a>·链表</h1><p>数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。</p>
<p>链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。</p>
<h2 id="典型题目：-1"><a href="#典型题目：-1" class="headerlink" title="典型题目："></a>典型题目：</h2><table>
<thead>
<tr>
<th>题目</th>
<th align="right">力扣链接</th>
<th align="right">解法</th>
<th align="right">评价</th>
</tr>
</thead>
<tbody><tr>
<td>链表理论</td>
<td align="right"><a href="https://leetcode.cn/problems/remove-element/description/">链表理论</a></td>
<td align="right">整节都是好东西</td>
<td align="right">都是经典题目</td>
</tr>
<tr>
<td>链表相交</td>
<td align="right"><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">链表相交</a></td>
<td align="right">哈希表（存储+查找）、双指针（数学证明有相交能相遇，无相交会同时NULL）、硬解（谁长先先多走）</td>
<td align="right">很有意思的题目</td>
</tr>
<tr>
<td>设计链表</td>
<td align="right">707</td>
<td align="right">基本功</td>
<td align="right">对链表的详细理解</td>
</tr>
<tr>
<td></td>
<td align="right"></td>
<td align="right"></td>
<td align="right"></td>
</tr>
</tbody></table>
<h1 id="·哈希表"><a href="#·哈希表" class="headerlink" title="·哈希表"></a>·哈希表</h1><p>哈希法是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p>
<p>如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！</p>
<h2 id="典型题目：-2"><a href="#典型题目：-2" class="headerlink" title="典型题目："></a>典型题目：</h2><table>
<thead>
<tr>
<th>题目</th>
<th align="right">力扣链接</th>
<th align="right">解法</th>
<th align="right">评价</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td align="right"></td>
<td align="right"></td>
<td align="right"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构(二)————堆、图</title>
    <url>//%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>利用堆进行排序，可以完美解决“第几大&#x2F;小的数”问题。<br>堆是一种满足特定条件的完全二叉树，分为小顶堆和大顶堆两种。JAVA，C++这种老牌语言可以使用优先队列实现堆，JS&#x2F;TS可以用数组&#x2F;二叉树来表示。</p>
<p>例题： <a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/?envType=study-plan-v2&envId=top-100-liked">力扣215:数组中的第K个最大元素</a></p>
<p>示例代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; nums </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; k </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125; </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"> <span class="comment">// 整个流程就是上浮下沉  </span></span><br><span class="line"><span class="keyword">var</span> findKthLargest = <span class="keyword">function</span>(<span class="params">nums, k</span>) &#123;  </span><br><span class="line">   <span class="keyword">let</span> heapSize=nums.<span class="property">length</span>  </span><br><span class="line">    <span class="title function_">buildMaxHeap</span>(nums,heapSize) <span class="comment">// 构建好了一个大顶堆  </span></span><br><span class="line">    <span class="comment">// 进行下沉 大顶堆是最大元素下沉到末尾  </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=nums.<span class="property">length</span>-<span class="number">1</span>;i&gt;=nums.<span class="property">length</span>-k+<span class="number">1</span>;i--)&#123;  </span><br><span class="line">        <span class="title function_">swap</span>(nums,<span class="number">0</span>,i)  </span><br><span class="line">        --heapSize <span class="comment">// 下沉后的元素不参与到大顶堆的调整  </span></span><br><span class="line">        <span class="comment">// 重新调整大顶堆  </span></span><br><span class="line">         <span class="title function_">maxHeapify</span>(nums, <span class="number">0</span>, heapSize);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>]  </span><br><span class="line">   <span class="comment">// 自下而上构建一颗大顶堆  </span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">buildMaxHeap</span>(<span class="params">nums,heapSize</span>)&#123;  </span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="title class_">Math</span>.<span class="title function_">floor</span>(heapSize/<span class="number">2</span>)-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;  </span><br><span class="line">        <span class="title function_">maxHeapify</span>(nums,i,heapSize)  </span><br><span class="line">     &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">// 从左向右，自上而下的调整节点  </span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">maxHeapify</span>(<span class="params">nums,i,heapSize</span>)&#123;  </span><br><span class="line">       <span class="keyword">let</span> l=i*<span class="number">2</span>+<span class="number">1</span>  </span><br><span class="line">       <span class="keyword">let</span> r=i*<span class="number">2</span>+<span class="number">2</span>  </span><br><span class="line">       <span class="keyword">let</span> largest=i  </span><br><span class="line">       <span class="keyword">if</span>(l &lt; heapSize &amp;&amp; nums[l] &gt; nums[largest])&#123;  </span><br><span class="line">           largest=l  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">if</span>(r &lt; heapSize &amp;&amp; nums[r] &gt; nums[largest])&#123;  </span><br><span class="line">           largest=r  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">if</span>(largest!==i)&#123;  </span><br><span class="line">           <span class="title function_">swap</span>(nums,i,largest) <span class="comment">// 进行节点调整  </span></span><br><span class="line">           <span class="comment">// 继续调整下面的非叶子节点  </span></span><br><span class="line">           <span class="title function_">maxHeapify</span>(nums,largest,heapSize)  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">swap</span>(<span class="params">a,  i,  j</span>)&#123;  </span><br><span class="line">        <span class="keyword">let</span> temp = a[i];  </span><br><span class="line">        a[i] = a[j];  </span><br><span class="line">        a[j] = temp;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>例题：<a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/?envType=study-plan-v2&envId=top-100-liked">力扣200:岛屿数量</a>（有意思的搜索题目）</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>算法(一)————排序算法</title>
    <url>//%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>利用堆的属性，在建堆的过程中实现大顶堆和小顶堆，完美解决“第几大&#x2F;小的数”问题。</p>
<p>堆是一种满足特定条件的完全二叉树，分为小顶堆和大顶堆两种。JAVA，C++这种老牌语言可以使用优先队列实现堆，JS&#x2F;TS可以用数组&#x2F;二叉树来表示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//示例代码:</span><br><span class="line">    /** </span><br><span class="line">     * @param &#123;number[]&#125; nums </span><br><span class="line">     * @param &#123;number&#125; k </span><br><span class="line">     * @return &#123;number&#125; </span><br><span class="line">     */  </span><br><span class="line">     // 整个流程就是上浮下沉  </span><br><span class="line">    var findKthLargest = function(nums, k) &#123;  </span><br><span class="line">       let heapSize=nums.length  </span><br><span class="line">        buildMaxHeap(nums,heapSize) // 构建好了一个大顶堆  </span><br><span class="line">        // 进行下沉 大顶堆是最大元素下沉到末尾  </span><br><span class="line">        for(let i=nums.length-1;i&gt;=nums.length-k+1;i--)&#123;  </span><br><span class="line">            swap(nums,0,i)  </span><br><span class="line">            --heapSize // 下沉后的元素不参与到大顶堆的调整  </span><br><span class="line">            // 重新调整大顶堆  </span><br><span class="line">             maxHeapify(nums, 0, heapSize);  </span><br><span class="line">        &#125;  </span><br><span class="line">        return nums[0]  </span><br><span class="line">       // 自下而上构建一颗大顶堆  </span><br><span class="line">       function buildMaxHeap(nums,heapSize)&#123;  </span><br><span class="line">         for(let i=Math.floor(heapSize/2)-1;i&gt;=0;i--)&#123;  </span><br><span class="line">            maxHeapify(nums,i,heapSize)  </span><br><span class="line">         &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       // 从左向右，自上而下的调整节点  </span><br><span class="line">       function maxHeapify(nums,i,heapSize)&#123;  </span><br><span class="line">           let l=i*2+1  </span><br><span class="line">           let r=i*2+2  </span><br><span class="line">           let largest=i  </span><br><span class="line">           if(l &lt; heapSize &amp;&amp; nums[l] &gt; nums[largest])&#123;  </span><br><span class="line">               largest=l  </span><br><span class="line">           &#125;  </span><br><span class="line">           if(r &lt; heapSize &amp;&amp; nums[r] &gt; nums[largest])&#123;  </span><br><span class="line">               largest=r  </span><br><span class="line">           &#125;  </span><br><span class="line">           if(largest!==i)&#123;  </span><br><span class="line">               swap(nums,i,largest) // 进行节点调整  </span><br><span class="line">               // 继续调整下面的非叶子节点  </span><br><span class="line">               maxHeapify(nums,largest,heapSize)  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       function swap(a,  i,  j)&#123;  </span><br><span class="line">            let temp = a[i];  </span><br><span class="line">            a[i] = a[j];  </span><br><span class="line">            a[j] = temp;  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;;  </span><br></pre></td></tr></table></figure>

<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>算法(三)————做题技巧</title>
    <url>//%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/%E5%81%9A%E9%A2%98%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><p>运用快慢两个指针解题，能够大大缩短本身可能需要$O(n^2)$复杂度的遍历时间。</p>
<p>例题：力扣283移动零、11盛水最多的容器、15三数之和、力扣977有序数组的平方、</p>
<p>总之看到暴力法需要两层for循环的，就想想能不能用双指针。</p>
<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>例题：力扣3无重复字符的最长子串</p>
<h1 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h1><p>例题：力扣560和为K的子数组</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>算法(三)————动态规划</title>
    <url>//%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>笔试题目记录</title>
    <url>//%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%89%B9%E6%AE%8A%E8%AE%B0%E5%BD%95/%E7%AC%94%E8%AF%95%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="2024-5-28-深圳同行者Web前端实习"><a href="#2024-5-28-深圳同行者Web前端实习" class="headerlink" title="2024-5-28 深圳同行者Web前端实习"></a>2024-5-28 深圳同行者Web前端实习</h1><p>1、写一个函数，输入为一个数组，输出一个包含它所有子集的数组。<br>        <a href="https://leetcode.cn/problems/TVdhkn/">力扣LCR079.子集</a><br>    子集问题，可以用迭代法或者递归。迭代法中，假设数组有三个元素，子集就可以看做从000~111的二进制位变化，也就可以依此设置一个mask，通过mask的变换添加子集。<br>      递归法就用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代，O(n*2^)</span></span><br><span class="line"><span class="keyword">var</span> subsets = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> ans = [];</span><br><span class="line">	<span class="keyword">const</span> n = nums.<span class="property">length</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> mask=<span class="number">0</span>;mask&lt; (<span class="number">1</span>&lt;&lt;n);mask++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(mask &amp; (<span class="number">1</span>&lt;&lt;i))&#123;</span><br><span class="line">				t.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans.<span class="title function_">push</span>(t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------</span><br><span class="line"><span class="comment">//递归，O(n*2^)</span></span><br><span class="line"><span class="keyword">var</span> subsets = <span class="keyword">function</span>(<span class="params">nums</span>) &#123; </span><br><span class="line">	<span class="keyword">const</span> t = []; </span><br><span class="line">	<span class="keyword">const</span> ans = []; </span><br><span class="line">	<span class="keyword">const</span> n = nums.<span class="property">length</span>; </span><br><span class="line">	<span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">cur</span>) =&gt; &#123; </span><br><span class="line">		<span class="keyword">if</span> (cur === nums.<span class="property">length</span>) &#123; </span><br><span class="line">			ans.<span class="title function_">push</span>(t.<span class="title function_">slice</span>()); </span><br><span class="line">			<span class="keyword">return</span>; </span><br><span class="line">		&#125; </span><br><span class="line">		t.<span class="title function_">push</span>(nums[cur]); </span><br><span class="line">		<span class="title function_">dfs</span>(cur + <span class="number">1</span>, nums); </span><br><span class="line">		t.<span class="title function_">pop</span>(t.<span class="property">length</span> - <span class="number">1</span>); </span><br><span class="line">		<span class="title function_">dfs</span>(cur + <span class="number">1</span>, nums); </span><br><span class="line">	&#125; </span><br><span class="line">		<span class="title function_">dfs</span>(<span class="number">0</span>, nums); </span><br><span class="line">		<span class="keyword">return</span> ans; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>


<p>2、不使用split方法，实现两个函数：<br>    (1)输入字符串str和分隔符spl，输出被分割后的字符串数组。例：输入abc&amp;&amp;de和&amp;&amp;，输出[“abc”,”de”]。<br>    (2)输入字符串数组str和分隔符spl，输出合并后的字符串。例：输入[“abc”,”de”]和&amp;&amp;，输出abc&amp;&amp;de。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分割</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">customSplit</span>(<span class="params">str, spl</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> current = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; str.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.<span class="title function_">substring</span>(i, i + spl.<span class="property">length</span>) === spl) &#123;</span><br><span class="line">            result.<span class="title function_">push</span>(current);</span><br><span class="line">            current = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            i += spl.<span class="property">length</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current += str[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    result.<span class="title function_">push</span>(current); <span class="comment">// 添加最后一个部分</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;abc&amp;&amp;de&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> spl = <span class="string">&quot;&amp;&amp;&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">customSplit</span>(str, spl)); <span class="comment">// 输出 [&quot;abc&quot;, &quot;de&quot;]</span></span><br><span class="line">---------------------------------------------------------</span><br><span class="line"><span class="comment">//合并</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">customJoin</span>(<span class="params">arr, spl</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        result += arr[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; arr.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">            result += spl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;de&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> spl = <span class="string">&quot;&amp;&amp;&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">customJoin</span>(arr, spl)); <span class="comment">// 输出 &quot;abc&amp;&amp;de&quot;</span></span><br></pre></td></tr></table></figure>


<p>3、找出不大于n的最大质数<br>        [力扣204计数质数][anchor-3]<br>    其实只要想起来怎么找质数就行，两种方法，枚举和埃氏筛。枚举记得加上一个平方加速运算，埃氏筛记得原理是创一个数组，从小开始遍历到n，把遍历到的数的所有倍数都标记为0，剩下的全都是1~n的质数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//枚举，O(n√n)</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isPrime</span> = (<span class="params">x</span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>; i*i&lt;=x; ++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>( x%i == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ture;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------</span><br><span class="line"><span class="comment">//埃氏筛，O(nloglogn)</span></span><br><span class="line"><span class="keyword">var</span> countPrimes = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> isPrime = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">    isPrime[<span class="number">0</span>] = isPrime[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i*i; j&lt;=n; j+=i)&#123;<span class="comment">//精髓在这里</span></span><br><span class="line">            isPrime[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=n-<span class="number">1</span>;i&gt;<span class="number">0</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isPrime[i])&#123;</span><br><span class="line">            ans = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>4、数组中共有一千个数，数的范围在[0,999]，有且只有两个相同的数，找出这个数。<br>    map or set</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">findDuplicate</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> hashMap = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hashMap[arr[i]] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hashMap[arr[i]] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 如果没有找到重复的数字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [...<span class="title class_">Array</span>(<span class="number">999</span>).<span class="title function_">keys</span>(), <span class="number">500</span>]; <span class="comment">// 示例数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">findDuplicate</span>(arr));</span><br><span class="line">---------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findDuplicate</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.<span class="title function_">has</span>(arr[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        set.<span class="title function_">add</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 如果没有找到重复的数字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [...<span class="title class_">Array</span>(<span class="number">999</span>).<span class="title function_">keys</span>(), <span class="number">500</span>]; <span class="comment">// 示例数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">findDuplicate</span>(arr));</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>5、n个人(编号1~n)围成一个圈报数，从1报数到m，报到m的人出列，下一个人重新从1开始报数，求最后一个留下的人的编号。<br>    [约瑟夫环问题][anchor-5]，模拟单链表、数学递推、公式法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//循环链表</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createList</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="comment">//链表节点的数据结构</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">createNode</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">value</span>: value,</span><br><span class="line">            <span class="attr">next</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//链表头节点</span></span><br><span class="line">    <span class="keyword">let</span> head = <span class="title function_">createNode</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> node = head;</span><br><span class="line">    <span class="comment">//自头节点之后创建节点之间的关联关系</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= num; i++) &#123;</span><br><span class="line">        node.<span class="property">next</span> = <span class="title function_">createNode</span>(i);</span><br><span class="line">        node = node.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后一个节点指向头节点，构成循环链表</span></span><br><span class="line">    node.<span class="property">next</span> = head;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deleteListNode</span>(<span class="params">num, nth</span>) &#123;</span><br><span class="line">    <span class="comment">//创建数据长度为num的循环链表</span></span><br><span class="line">    <span class="keyword">let</span> node = <span class="title function_">createList</span>(num);</span><br><span class="line">    <span class="comment">//链表长度&gt;1时，继续下一轮</span></span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= nth - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == nth - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//i为nth-1，则node.next即为第nth个节点。剔除node.next</span></span><br><span class="line">                node.<span class="property">next</span> = node.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">                <span class="comment">//链表长度--</span></span><br><span class="line">                num--;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//剩余的最后一个节点的value值即为最后一人编号</span></span><br><span class="line">    <span class="keyword">return</span> node.<span class="property">value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//deleteListNode(m,n)即可得到最终结果</span></span><br><span class="line">---------------------------------------------------------</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Josephus</span>(<span class="params">num,nth</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="title class_">Josephus</span>(num-<span class="number">1</span>,nth)+nth)%num</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Josephus(N,M)+1即为最终编号</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="2024-6-4深圳学而思小高科学素养教师秋招提前批"><a href="#2024-6-4深圳学而思小高科学素养教师秋招提前批" class="headerlink" title="2024-6-4深圳学而思小高科学素养教师秋招提前批"></a>2024-6-4深圳学而思小高科学素养教师秋招提前批</h1><p>纯MBTI</p>
<h1 id="2024-6-5深圳腾讯音乐娱乐IOS客户端实习"><a href="#2024-6-5深圳腾讯音乐娱乐IOS客户端实习" class="headerlink" title="2024-6-5深圳腾讯音乐娱乐IOS客户端实习"></a>2024-6-5深圳腾讯音乐娱乐IOS客户端实习</h1><h3 id="一、编程题"><a href="#一、编程题" class="headerlink" title="一、编程题"></a>一、编程题</h3><h4 id="1、删除升序数组重复元素："><a href="#1、删除升序数组重复元素：" class="headerlink" title="1、删除升序数组重复元素："></a>1、删除升序数组重复元素：</h4><pre><code>~给一个长度为n的升序数组nums，删除一部分重复元素（需原地改变数组），让这个数组每个数字都严格大于前一个数（第一个数除外），返回删除后的数组长度，被操作过的数组前若干个数要严格单增。
</code></pre>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双指针，妙解法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> uniqueIndex = <span class="number">1</span>; <span class="comment">// 从第二个元素开始检查</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] !== nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            nums[uniqueIndex] = nums[i];</span><br><span class="line">            uniqueIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uniqueIndex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> newLength = <span class="title function_">removeDuplicates</span>(nums);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newLength); <span class="comment">// 输出新的数组长度</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nums.<span class="title function_">slice</span>(<span class="number">0</span>, newLength)); <span class="comment">// 输出新的数组内容</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2、螺旋矩阵"><a href="#2、螺旋矩阵" class="headerlink" title="2、螺旋矩阵"></a>2、螺旋矩阵</h4><p>背代码！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> generateMatrix = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> startX = startY = <span class="number">0</span>;   <span class="comment">// 起始位置</span></span><br><span class="line">    <span class="keyword">let</span> loop = <span class="title class_">Math</span>.<span class="title function_">floor</span>(n/<span class="number">2</span>);   <span class="comment">// 旋转圈数</span></span><br><span class="line">    <span class="keyword">let</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>(n/<span class="number">2</span>);    <span class="comment">// 中间位置</span></span><br><span class="line">    <span class="keyword">let</span> offset = <span class="number">1</span>;    <span class="comment">// 控制每一层填充元素个数</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">1</span>;     <span class="comment">// 更新填充数字</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (loop--) &#123;</span><br><span class="line">        <span class="keyword">let</span> row = startX, col = startY;</span><br><span class="line">        <span class="comment">// 上行从左到右（左闭右开）</span></span><br><span class="line">        <span class="keyword">for</span> (; col &lt; n - offset; col++) &#123;</span><br><span class="line">            res[row][col] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右列从上到下（左闭右开）</span></span><br><span class="line">        <span class="keyword">for</span> (; row &lt; n - offset; row++) &#123;</span><br><span class="line">            res[row][col] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下行从右到左（左闭右开）</span></span><br><span class="line">        <span class="keyword">for</span> (; col &gt; startY; col--) &#123;</span><br><span class="line">            res[row][col] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左列做下到上（左闭右开）</span></span><br><span class="line">        <span class="keyword">for</span> (; row &gt; startX; row--) &#123;</span><br><span class="line">            res[row][col] = count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新起始位置</span></span><br><span class="line">        startX++;</span><br><span class="line">        startY++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新offset</span></span><br><span class="line">        offset += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span></span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        res[mid][mid] = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3、括号区间匹配"><a href="#3、括号区间匹配" class="headerlink" title="3、括号区间匹配"></a>3、括号区间匹配</h4><pre><code>由[]、()组成的字符串，最少插入多少个括号可以实现匹配？输出所需的括号数量。
</code></pre>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="二、问答题"><a href="#二、问答题" class="headerlink" title="二、问答题"></a>二、问答题</h3><h4 id="1、进程和线程有什么区别？进程间通信方式有哪些？"><a href="#1、进程和线程有什么区别？进程间通信方式有哪些？" class="headerlink" title="1、进程和线程有什么区别？进程间通信方式有哪些？"></a>1、进程和线程有什么区别？进程间通信方式有哪些？</h4><h4 id="2、列举常用数据结构，各自的特点和使用场景"><a href="#2、列举常用数据结构，各自的特点和使用场景" class="headerlink" title="2、列举常用数据结构，各自的特点和使用场景"></a>2、列举常用数据结构，各自的特点和使用场景</h4><h4 id="3、多线程编程要注意哪些情况？"><a href="#3、多线程编程要注意哪些情况？" class="headerlink" title="3、多线程编程要注意哪些情况？"></a>3、多线程编程要注意哪些情况？</h4><h4 id="4、HTTP请求头包含哪些内容？"><a href="#4、HTTP请求头包含哪些内容？" class="headerlink" title="4、HTTP请求头包含哪些内容？"></a>4、HTTP请求头包含哪些内容？</h4><h4 id="5、TCP和HTTP的具体区别？"><a href="#5、TCP和HTTP的具体区别？" class="headerlink" title="5、TCP和HTTP的具体区别？"></a>5、TCP和HTTP的具体区别？</h4><h4 id="6、怎么提升在线视频的播放秒开率？"><a href="#6、怎么提升在线视频的播放秒开率？" class="headerlink" title="6、怎么提升在线视频的播放秒开率？"></a>6、怎么提升在线视频的播放秒开率？</h4>]]></content>
      <categories>
        <category>笔面记录</category>
      </categories>
      <tags>
        <tag>笔试题</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题目记录</title>
    <url>//%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%89%B9%E6%AE%8A%E8%AE%B0%E5%BD%95/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>笔面记录</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
</search>
