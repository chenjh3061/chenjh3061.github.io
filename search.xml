<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>//hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.<br><a href="https://www.zhihu.com/column/c_1502937018040057858">https://www.zhihu.com/column/c_1502937018040057858</a></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new (post) <span class="string">&quot;My New Post&quot;</span>    (post可写可不写)  </span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server / hexo s</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<p>常见命令：<br>hexo new “postName”      # 新建文章<br>hexo new page “pageName” # 新建页面<br>hexo generate            # 生成静态页面至public目录<br>hexo server              # 开启预览访问端口（默认端口4000，’ctrl + c’关闭server）<br>hexo deploy              # 部署到GitHub<br>hexo help                # 查看帮助<br>hexo version             # 查看Hexo的版本<br>缩写命令：<br>hexo n &#x3D;&#x3D; hexo new<br>hexo g &#x3D;&#x3D; hexo generate<br>hexo s &#x3D;&#x3D; hexo server<br>hexo d &#x3D;&#x3D; hexo deploy<br>组合命令：<br>hexo s -g   # 生成并本地预览<br>hexo d -g   # 生成并上传</p>
]]></content>
  </entry>
  <entry>
    <title>计算机网络总纲</title>
    <url>//%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BA%B2/</url>
    <content><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><h3 id="计算机网络的概念、组成、分类"><a href="#计算机网络的概念、组成、分类" class="headerlink" title="计算机网络的概念、组成、分类"></a>计算机网络的概念、组成、分类</h3><h3 id="体系结构-与-分层结构"><a href="#体系结构-与-分层结构" class="headerlink" title="体系结构 与 分层结构"></a>体系结构 与 分层结构</h3><h3 id="ISO-OSI参考模型和TCP-IP模型"><a href="#ISO-OSI参考模型和TCP-IP模型" class="headerlink" title="ISO&#x2F;OSI参考模型和TCP&#x2F;IP模型"></a>ISO&#x2F;OSI参考模型和TCP&#x2F;IP模型</h3><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络总纲</title>
    <url>//%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%80%BB%E7%BA%B2/</url>
    <content><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h2 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h2><h2 id="数据的表示和运算"><a href="#数据的表示和运算" class="headerlink" title="数据的表示和运算"></a>数据的表示和运算</h2><h2 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h2><h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><h2 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h2><h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><h2 id="输入-输出系统"><a href="#输入-输出系统" class="headerlink" title="输入&#x2F;输出系统"></a>输入&#x2F;输出系统</h2>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构总纲</title>
    <url>//%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BA%B2/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><h3 id="数据结构（三要素）"><a href="#数据结构（三要素）" class="headerlink" title="数据结构（三要素）"></a>数据结构（三要素）</h3><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><h5 id="线性结构：线性表、栈、队列"><a href="#线性结构：线性表、栈、队列" class="headerlink" title="线性结构：线性表、栈、队列"></a>线性结构：线性表、栈、队列</h5><h5 id="树、图、集合"><a href="#树、图、集合" class="headerlink" title="树、图、集合"></a>树、图、集合</h5><h4 id="存储结构（物理结构）"><a href="#存储结构（物理结构）" class="headerlink" title="存储结构（物理结构）"></a>存储结构（物理结构）</h4><h4 id="数据的运算"><a href="#数据的运算" class="headerlink" title="数据的运算"></a>数据的运算</h4><h3 id="五个特征"><a href="#五个特征" class="headerlink" title="五个特征"></a>五个特征</h3><h4 id="算法定义"><a href="#算法定义" class="headerlink" title="算法定义"></a>算法定义</h4><h4 id="五个特征：有穷性、确定性、可行性、输入、输出"><a href="#五个特征：有穷性、确定性、可行性、输入、输出" class="headerlink" title="五个特征：有穷性、确定性、可行性、输入、输出"></a>五个特征：有穷性、确定性、可行性、输入、输出</h4><h4 id="效率的度量"><a href="#效率的度量" class="headerlink" title="效率的度量"></a>效率的度量</h4><h5 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h5><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><h4 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h4><h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><h4 id="单链表、双链表、循环链表（指针实现）"><a href="#单链表、双链表、循环链表（指针实现）" class="headerlink" title="单链表、双链表、循环链表（指针实现）"></a>单链表、双链表、循环链表（指针实现）</h4><h4 id="静态链表（数组实现）"><a href="#静态链表（数组实现）" class="headerlink" title="静态链表（数组实现）"></a>静态链表（数组实现）</h4><h2 id="栈、队列和数组"><a href="#栈、队列和数组" class="headerlink" title="栈、队列和数组"></a>栈、队列和数组</h2><h3 id="操作受限"><a href="#操作受限" class="headerlink" title="操作受限"></a>操作受限</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><h5 id="顺序栈、链共享栈"><a href="#顺序栈、链共享栈" class="headerlink" title="顺序栈、链共享栈"></a>顺序栈、链共享栈</h5><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><h5 id="循环队列、链式队列、双端队列"><a href="#循环队列、链式队列、双端队列" class="headerlink" title="循环队列、链式队列、双端队列"></a>循环队列、链式队列、双端队列</h5><h3 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h3><h4 id="数组（重点易错，回看）"><a href="#数组（重点易错，回看）" class="headerlink" title="数组（重点易错，回看）"></a><strong>数组</strong>（重点易错，回看）</h4><h5 id="一维数组、多维数组（压缩存储、稀疏矩阵）"><a href="#一维数组、多维数组（压缩存储、稀疏矩阵）" class="headerlink" title="一维数组、多维数组（压缩存储、稀疏矩阵）"></a>一维数组、多维数组（压缩存储、稀疏矩阵）</h5><h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><h3 id="基本概念：主串、子串、串长"><a href="#基本概念：主串、子串、串长" class="headerlink" title="基本概念：主串、子串、串长"></a>基本概念：主串、子串、串长</h3><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><h4 id="定长顺序存储"><a href="#定长顺序存储" class="headerlink" title="定长顺序存储"></a>定长顺序存储</h4><h4 id="堆分配存储"><a href="#堆分配存储" class="headerlink" title="堆分配存储"></a>堆分配存储</h4><h4 id="块链存储"><a href="#块链存储" class="headerlink" title="块链存储"></a>块链存储</h4><h3 id="模式匹配算法"><a href="#模式匹配算法" class="headerlink" title="模式匹配算法"></a>模式匹配算法</h3><h4 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h4><h4 id="KMP：部分匹配值表、next数组、next函数推理过程"><a href="#KMP：部分匹配值表、next数组、next函数推理过程" class="headerlink" title="KMP：部分匹配值表、next数组、next函数推理过程"></a>KMP：部分匹配值表、next数组、next函数推理过程</h4><h4 id="KMP算法的进一步改进"><a href="#KMP算法的进一步改进" class="headerlink" title="KMP算法的进一步改进"></a>KMP算法的进一步改进</h4><h2 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="概念、定义、存储结构"><a href="#概念、定义、存储结构" class="headerlink" title="概念、定义、存储结构"></a>概念、定义、存储结构</h4><h4 id="操作：三种遍历、线索二叉树"><a href="#操作：三种遍历、线索二叉树" class="headerlink" title="操作：三种遍历、线索二叉树"></a>操作：三种遍历、线索二叉树</h4><h4 id="应用：并查集、哈夫曼树"><a href="#应用：并查集、哈夫曼树" class="headerlink" title="应用：并查集、哈夫曼树"></a>应用：并查集、哈夫曼树</h4><h3 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h3><h4 id="概念：定义、存储结构"><a href="#概念：定义、存储结构" class="headerlink" title="概念：定义、存储结构"></a>概念：定义、存储结构</h4><h4 id="操作：与二叉树的转换、遍历"><a href="#操作：与二叉树的转换、遍历" class="headerlink" title="操作：与二叉树的转换、遍历"></a>操作：与二叉树的转换、遍历</h4><h4 id="应用：并查集"><a href="#应用：并查集" class="headerlink" title="应用：并查集"></a>应用：并查集</h4><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构（一）——绪论&amp;数组、链表、字符串</title>
    <url>//%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="0、引"><a href="#0、引" class="headerlink" title="0、引"></a>0、引</h1><p>这里记录一些题目收集情况，主要逻辑来自 <a href="https://www.programmercarl.com/">代码随想录</a></p>
<h1 id="·数组"><a href="#·数组" class="headerlink" title="·数组"></a>·数组</h1><p>经常结合双指针法</p>
<h2 id="典型题目："><a href="#典型题目：" class="headerlink" title="典型题目："></a>典型题目：</h2><table>
<thead>
<tr>
<th>题目</th>
<th>力扣链接</th>
<th>解法</th>
<th>评价</th>
</tr>
</thead>
<tbody><tr>
<td>移除元素</td>
<td><a href="https://leetcode.cn/problems/remove-element/description/">移除元素</a></td>
<td>推荐双指针</td>
<td>触类旁通</td>
</tr>
<tr>
<td>有序数组平方</td>
<td><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">有序数组平方</a></td>
<td>双指针</td>
<td></td>
</tr>
<tr>
<td>[[笔试题目#2、[螺旋矩阵]|螺旋矩阵]]</td>
<td><a href="https://leetcode.cn/problems/spiral-matrix-ii/">螺旋矩阵</a></td>
<td>背代码</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="·链表"><a href="#·链表" class="headerlink" title="·链表"></a>·链表</h1><p>数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。</p>
<p>链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。</p>
<h2 id="典型题目：-1"><a href="#典型题目：-1" class="headerlink" title="典型题目："></a>典型题目：</h2><table>
<thead>
<tr>
<th>题目</th>
<th align="right">力扣链接</th>
<th align="right">解法</th>
<th align="right">评价</th>
</tr>
</thead>
<tbody><tr>
<td>链表理论</td>
<td align="right"><a href="https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%93%BE%E8%A1%A8%E7%9A%84%E7%B1%BB%E5%9E%8B">链表理论</a></td>
<td align="right">整节都是好东西</td>
<td align="right">都是经典题目</td>
</tr>
<tr>
<td>链表相交</td>
<td align="right"><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/">链表相交</a></td>
<td align="right">哈希表（存储+查找）、双指针（数学证明有相交能相遇，无相交会同时NULL）、硬解（谁长先先多走）</td>
<td align="right">很有意思的题目</td>
</tr>
<tr>
<td>设计链表</td>
<td align="right">707</td>
<td align="right">基本功</td>
<td align="right">对链表的详细理解</td>
</tr>
<tr>
<td></td>
<td align="right"></td>
<td align="right"></td>
<td align="right"></td>
</tr>
</tbody></table>
<h1 id="·哈希表"><a href="#·哈希表" class="headerlink" title="·哈希表"></a>·哈希表</h1><p>哈希法是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p>
<p>如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！</p>
<h2 id="典型题目：-2"><a href="#典型题目：-2" class="headerlink" title="典型题目："></a>典型题目：</h2><table>
<thead>
<tr>
<th>题目</th>
<th align="right">力扣链接</th>
<th align="right">解法</th>
<th align="right">评价</th>
</tr>
</thead>
<tbody><tr>
<td>[和为K的子数组]</td>
<td align="right"><a href="https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&envId=top-100-liked">和为K的子数组</a></td>
<td align="right"></td>
<td align="right"></td>
</tr>
<tr>
<td></td>
<td align="right"></td>
<td align="right"></td>
<td align="right"></td>
</tr>
<tr>
<td></td>
<td align="right"></td>
<td align="right"></td>
<td align="right"></td>
</tr>
</tbody></table>
<p>^218568</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构(二)————堆、图</title>
    <url>//%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>利用堆进行排序，可以完美解决“第几大&#x2F;小的数”问题。<br>堆是一种满足特定条件的完全二叉树，分为小顶堆和大顶堆两种。JAVA，C++这种老牌语言可以使用优先队列实现堆，JS&#x2F;TS可以用数组&#x2F;二叉树来表示。</p>
<h2 id="典型题目："><a href="#典型题目：" class="headerlink" title="典型题目："></a>典型题目：</h2><table>
<thead>
<tr>
<th>题目</th>
<th align="right">力扣链接</th>
<th align="right">解法</th>
<th align="right">评价</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td align="right"></td>
<td align="right"></td>
<td align="right"></td>
</tr>
</tbody></table>
<p>例题： <a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/?envType=study-plan-v2&envId=top-100-liked">力扣215:数组中的第K个最大元素</a></p>
<p>示例代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; nums </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; k </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125; </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"> <span class="comment">// 整个流程就是上浮下沉  </span></span><br><span class="line"><span class="keyword">var</span> findKthLargest = <span class="keyword">function</span>(<span class="params">nums, k</span>) &#123;  </span><br><span class="line">   <span class="keyword">let</span> heapSize=nums.<span class="property">length</span>  </span><br><span class="line">    <span class="title function_">buildMaxHeap</span>(nums,heapSize) <span class="comment">// 构建好了一个大顶堆  </span></span><br><span class="line">    <span class="comment">// 进行下沉 大顶堆是最大元素下沉到末尾  </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=nums.<span class="property">length</span>-<span class="number">1</span>;i&gt;=nums.<span class="property">length</span>-k+<span class="number">1</span>;i--)&#123;  </span><br><span class="line">        <span class="title function_">swap</span>(nums,<span class="number">0</span>,i)  </span><br><span class="line">        --heapSize <span class="comment">// 下沉后的元素不参与到大顶堆的调整  </span></span><br><span class="line">        <span class="comment">// 重新调整大顶堆  </span></span><br><span class="line">         <span class="title function_">maxHeapify</span>(nums, <span class="number">0</span>, heapSize);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>]  </span><br><span class="line">   <span class="comment">// 自下而上构建一颗大顶堆  </span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">buildMaxHeap</span>(<span class="params">nums,heapSize</span>)&#123;  </span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="title class_">Math</span>.<span class="title function_">floor</span>(heapSize/<span class="number">2</span>)-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;  </span><br><span class="line">        <span class="title function_">maxHeapify</span>(nums,i,heapSize)  </span><br><span class="line">     &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">// 从左向右，自上而下的调整节点  </span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">maxHeapify</span>(<span class="params">nums,i,heapSize</span>)&#123;  </span><br><span class="line">       <span class="keyword">let</span> l=i*<span class="number">2</span>+<span class="number">1</span>  </span><br><span class="line">       <span class="keyword">let</span> r=i*<span class="number">2</span>+<span class="number">2</span>  </span><br><span class="line">       <span class="keyword">let</span> largest=i  </span><br><span class="line">       <span class="keyword">if</span>(l &lt; heapSize &amp;&amp; nums[l] &gt; nums[largest])&#123;  </span><br><span class="line">           largest=l  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">if</span>(r &lt; heapSize &amp;&amp; nums[r] &gt; nums[largest])&#123;  </span><br><span class="line">           largest=r  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">if</span>(largest!==i)&#123;  </span><br><span class="line">           <span class="title function_">swap</span>(nums,i,largest) <span class="comment">// 进行节点调整  </span></span><br><span class="line">           <span class="comment">// 继续调整下面的非叶子节点  </span></span><br><span class="line">           <span class="title function_">maxHeapify</span>(nums,largest,heapSize)  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">swap</span>(<span class="params">a,  i,  j</span>)&#123;  </span><br><span class="line">        <span class="keyword">let</span> temp = a[i];  </span><br><span class="line">        a[i] = a[j];  </span><br><span class="line">        a[j] = temp;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>例题：[力扣200:岛屿数量][anchor-id]（有意思的搜索题目）</p>
<h2 id="典型题目：-1"><a href="#典型题目：-1" class="headerlink" title="典型题目："></a>典型题目：</h2><table>
<thead>
<tr>
<th>题目</th>
<th align="right">力扣链接</th>
<th align="right">解法</th>
<th align="right">评价</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td align="right"></td>
<td align="right"></td>
<td align="right"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>算法(一)————排序算法</title>
    <url>//%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>利用堆的属性，在建堆的过程中实现大顶堆和小顶堆，完美解决“第几大&#x2F;小的数”问题。</p>
<p>堆是一种满足特定条件的完全二叉树，分为小顶堆和大顶堆两种。JAVA，C++这种老牌语言可以使用优先队列实现堆，JS&#x2F;TS可以用数组&#x2F;二叉树来表示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//示例代码:</span><br><span class="line">    /** </span><br><span class="line">     * @param &#123;number[]&#125; nums </span><br><span class="line">     * @param &#123;number&#125; k </span><br><span class="line">     * @return &#123;number&#125; </span><br><span class="line">     */  </span><br><span class="line">     // 整个流程就是上浮下沉  </span><br><span class="line">    var findKthLargest = function(nums, k) &#123;  </span><br><span class="line">       let heapSize=nums.length  </span><br><span class="line">        buildMaxHeap(nums,heapSize) // 构建好了一个大顶堆  </span><br><span class="line">        // 进行下沉 大顶堆是最大元素下沉到末尾  </span><br><span class="line">        for(let i=nums.length-1;i&gt;=nums.length-k+1;i--)&#123;  </span><br><span class="line">            swap(nums,0,i)  </span><br><span class="line">            --heapSize // 下沉后的元素不参与到大顶堆的调整  </span><br><span class="line">            // 重新调整大顶堆  </span><br><span class="line">             maxHeapify(nums, 0, heapSize);  </span><br><span class="line">        &#125;  </span><br><span class="line">        return nums[0]  </span><br><span class="line">       // 自下而上构建一颗大顶堆  </span><br><span class="line">       function buildMaxHeap(nums,heapSize)&#123;  </span><br><span class="line">         for(let i=Math.floor(heapSize/2)-1;i&gt;=0;i--)&#123;  </span><br><span class="line">            maxHeapify(nums,i,heapSize)  </span><br><span class="line">         &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       // 从左向右，自上而下的调整节点  </span><br><span class="line">       function maxHeapify(nums,i,heapSize)&#123;  </span><br><span class="line">           let l=i*2+1  </span><br><span class="line">           let r=i*2+2  </span><br><span class="line">           let largest=i  </span><br><span class="line">           if(l &lt; heapSize &amp;&amp; nums[l] &gt; nums[largest])&#123;  </span><br><span class="line">               largest=l  </span><br><span class="line">           &#125;  </span><br><span class="line">           if(r &lt; heapSize &amp;&amp; nums[r] &gt; nums[largest])&#123;  </span><br><span class="line">               largest=r  </span><br><span class="line">           &#125;  </span><br><span class="line">           if(largest!==i)&#123;  </span><br><span class="line">               swap(nums,i,largest) // 进行节点调整  </span><br><span class="line">               // 继续调整下面的非叶子节点  </span><br><span class="line">               maxHeapify(nums,largest,heapSize)  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       function swap(a,  i,  j)&#123;  </span><br><span class="line">            let temp = a[i];  </span><br><span class="line">            a[i] = a[j];  </span><br><span class="line">            a[j] = temp;  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;;  </span><br></pre></td></tr></table></figure>

<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>算法(三)————做题技巧</title>
    <url>//%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/%E5%81%9A%E9%A2%98%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>总提醒：<br>    多考虑一些特殊情况，题目前面的判断。</p>
<h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><p>哈希表可以处理很多查找情况，优化解题速度甚至提供新解法。</p>
<p>例题：560和为k的子数组、</p>
<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><p>运用快慢两个指针解题，（头头指针&#x2F;快慢指针，头尾指针）能够大大缩短本身可能需要$O(n^2)$复杂度的遍历时间。</p>
<p>例题：力扣283移动零、11盛水最多的容器、15三数之和、16最接近的三数之和、力扣977有序数组的平方、[[笔试题目#1、[删除升序数组重复元素]：|删除升序数组重复元素]]、</p>
<p>&#x3D;&#x3D;总之看到暴力法需要两层for循环的，就想想能不能用双指针&#x3D;&#x3D;。</p>
<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>分定宽和不定宽两种，如果需要查找窗内元素可以借助map。</p>
<p>例题：力扣3无重复字符的最长子串、483找到字符串中所有字母异位词（配合map）、</p>
<h1 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h1><p>例题：[[数组链表哈希表#^218568|力扣560和为K的子数组]]、</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>算法(二)————动态规划</title>
    <url>//%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>笔试题目记录</title>
    <url>//%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%89%B9%E6%AE%8A%E8%AE%B0%E5%BD%95/%E7%AC%94%E8%AF%95%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="2024-5-28-深圳同行者Web前端实习"><a href="#2024-5-28-深圳同行者Web前端实习" class="headerlink" title="2024-5-28 深圳同行者Web前端实习"></a>2024-5-28 深圳同行者Web前端实习</h1><p>1、写一个函数，输入为一个数组，输出一个包含它所有子集的数组。<br>        <a href="https://leetcode.cn/problems/TVdhkn/">力扣LCR079.子集</a><br>    子集问题，可以用迭代法或者递归。迭代法中，假设数组有三个元素，子集就可以看做从000~111的二进制位变化，也就可以依此设置一个mask，通过mask的变换添加子集。<br>      递归法就用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代，O(n*2^)</span></span><br><span class="line"><span class="keyword">var</span> subsets = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> ans = [];</span><br><span class="line">	<span class="keyword">const</span> n = nums.<span class="property">length</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> mask=<span class="number">0</span>;mask&lt; (<span class="number">1</span>&lt;&lt;n);mask++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(mask &amp; (<span class="number">1</span>&lt;&lt;i))&#123;</span><br><span class="line">				t.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans.<span class="title function_">push</span>(t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------</span><br><span class="line"><span class="comment">//递归，O(n*2^)</span></span><br><span class="line"><span class="keyword">var</span> subsets = <span class="keyword">function</span>(<span class="params">nums</span>) &#123; </span><br><span class="line">	<span class="keyword">const</span> t = []; </span><br><span class="line">	<span class="keyword">const</span> ans = []; </span><br><span class="line">	<span class="keyword">const</span> n = nums.<span class="property">length</span>; </span><br><span class="line">	<span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">cur</span>) =&gt; &#123; </span><br><span class="line">		<span class="keyword">if</span> (cur === nums.<span class="property">length</span>) &#123; </span><br><span class="line">			ans.<span class="title function_">push</span>(t.<span class="title function_">slice</span>()); </span><br><span class="line">			<span class="keyword">return</span>; </span><br><span class="line">		&#125; </span><br><span class="line">		t.<span class="title function_">push</span>(nums[cur]); </span><br><span class="line">		<span class="title function_">dfs</span>(cur + <span class="number">1</span>, nums); </span><br><span class="line">		t.<span class="title function_">pop</span>(t.<span class="property">length</span> - <span class="number">1</span>); </span><br><span class="line">		<span class="title function_">dfs</span>(cur + <span class="number">1</span>, nums); </span><br><span class="line">	&#125; </span><br><span class="line">		<span class="title function_">dfs</span>(<span class="number">0</span>, nums); </span><br><span class="line">		<span class="keyword">return</span> ans; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>


<p>2、不使用split方法，实现两个函数：<br>    (1)输入字符串str和分隔符spl，输出被分割后的字符串数组。例：输入abc&amp;&amp;de和&amp;&amp;，输出[“abc”,”de”]。<br>    (2)输入字符串数组str和分隔符spl，输出合并后的字符串。例：输入[“abc”,”de”]和&amp;&amp;，输出abc&amp;&amp;de。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分割</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">customSplit</span>(<span class="params">str, spl</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> current = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; str.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.<span class="title function_">substring</span>(i, i + spl.<span class="property">length</span>) === spl) &#123;</span><br><span class="line">            result.<span class="title function_">push</span>(current);</span><br><span class="line">            current = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            i += spl.<span class="property">length</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current += str[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    result.<span class="title function_">push</span>(current); <span class="comment">// 添加最后一个部分</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;abc&amp;&amp;de&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> spl = <span class="string">&quot;&amp;&amp;&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">customSplit</span>(str, spl)); <span class="comment">// 输出 [&quot;abc&quot;, &quot;de&quot;]</span></span><br><span class="line">---------------------------------------------------------</span><br><span class="line"><span class="comment">//合并</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">customJoin</span>(<span class="params">arr, spl</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        result += arr[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; arr.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">            result += spl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;de&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> spl = <span class="string">&quot;&amp;&amp;&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">customJoin</span>(arr, spl)); <span class="comment">// 输出 &quot;abc&amp;&amp;de&quot;</span></span><br></pre></td></tr></table></figure>


<p>3、找出不大于n的最大质数<br>        [力扣204计数质数][anchor-3]<br>    其实只要想起来怎么找质数就行，两种方法，枚举和埃氏筛。枚举记得加上一个平方加速运算，埃氏筛记得原理是创一个数组，从小开始遍历到n，把遍历到的数的所有倍数都标记为0，剩下的全都是1~n的质数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//枚举，O(n√n)</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isPrime</span> = (<span class="params">x</span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>; i*i&lt;=x; ++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>( x%i == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ture;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------</span><br><span class="line"><span class="comment">//埃氏筛，O(nloglogn)</span></span><br><span class="line"><span class="keyword">var</span> countPrimes = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> isPrime = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">    isPrime[<span class="number">0</span>] = isPrime[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i*i; j&lt;=n; j+=i)&#123;<span class="comment">//精髓在这里</span></span><br><span class="line">            isPrime[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=n-<span class="number">1</span>;i&gt;<span class="number">0</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isPrime[i])&#123;</span><br><span class="line">            ans = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>4、数组中共有一千个数，数的范围在[0,999]，有且只有两个相同的数，找出这个数。<br>    map or set</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">findDuplicate</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> hashMap = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hashMap[arr[i]] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hashMap[arr[i]] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 如果没有找到重复的数字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [...<span class="title class_">Array</span>(<span class="number">999</span>).<span class="title function_">keys</span>(), <span class="number">500</span>]; <span class="comment">// 示例数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">findDuplicate</span>(arr));</span><br><span class="line">---------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findDuplicate</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.<span class="title function_">has</span>(arr[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        set.<span class="title function_">add</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 如果没有找到重复的数字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [...<span class="title class_">Array</span>(<span class="number">999</span>).<span class="title function_">keys</span>(), <span class="number">500</span>]; <span class="comment">// 示例数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">findDuplicate</span>(arr));</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>5、n个人(编号1~n)围成一个圈报数，从1报数到m，报到m的人出列，下一个人重新从1开始报数，求最后一个留下的人的编号。<br>    [约瑟夫环问题][anchor-5]，模拟单链表、数学递推、公式法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//循环链表</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createList</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="comment">//链表节点的数据结构</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">createNode</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">value</span>: value,</span><br><span class="line">            <span class="attr">next</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//链表头节点</span></span><br><span class="line">    <span class="keyword">let</span> head = <span class="title function_">createNode</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> node = head;</span><br><span class="line">    <span class="comment">//自头节点之后创建节点之间的关联关系</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= num; i++) &#123;</span><br><span class="line">        node.<span class="property">next</span> = <span class="title function_">createNode</span>(i);</span><br><span class="line">        node = node.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后一个节点指向头节点，构成循环链表</span></span><br><span class="line">    node.<span class="property">next</span> = head;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deleteListNode</span>(<span class="params">num, nth</span>) &#123;</span><br><span class="line">    <span class="comment">//创建数据长度为num的循环链表</span></span><br><span class="line">    <span class="keyword">let</span> node = <span class="title function_">createList</span>(num);</span><br><span class="line">    <span class="comment">//链表长度&gt;1时，继续下一轮</span></span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= nth - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == nth - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//i为nth-1，则node.next即为第nth个节点。剔除node.next</span></span><br><span class="line">                node.<span class="property">next</span> = node.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">                <span class="comment">//链表长度--</span></span><br><span class="line">                num--;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//剩余的最后一个节点的value值即为最后一人编号</span></span><br><span class="line">    <span class="keyword">return</span> node.<span class="property">value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//deleteListNode(m,n)即可得到最终结果</span></span><br><span class="line">---------------------------------------------------------</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Josephus</span>(<span class="params">num,nth</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="title class_">Josephus</span>(num-<span class="number">1</span>,nth)+nth)%num</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Josephus(N,M)+1即为最终编号</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="2024-6-4深圳学而思小高科学素养教师秋招提前批"><a href="#2024-6-4深圳学而思小高科学素养教师秋招提前批" class="headerlink" title="2024-6-4深圳学而思小高科学素养教师秋招提前批"></a>2024-6-4深圳学而思小高科学素养教师秋招提前批</h1><p>纯MBTI</p>
<h1 id="2024-6-5深圳腾讯音乐娱乐IOS客户端实习"><a href="#2024-6-5深圳腾讯音乐娱乐IOS客户端实习" class="headerlink" title="2024-6-5深圳腾讯音乐娱乐IOS客户端实习"></a>2024-6-5深圳腾讯音乐娱乐IOS客户端实习</h1><h3 id="一、编程题"><a href="#一、编程题" class="headerlink" title="一、编程题"></a>一、编程题</h3><h4 id="1、-删除升序数组重复元素-："><a href="#1、-删除升序数组重复元素-：" class="headerlink" title="1、[删除升序数组重复元素]："></a>1、[删除升序数组重复元素]：</h4><pre><code>~给一个长度为n的升序数组nums，删除一部分重复元素（需原地改变数组），让这个数组每个数字都严格大于前一个数（第一个数除外），返回删除后的数组长度，被操作过的数组前若干个数要严格单增。
</code></pre>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双指针，妙解法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> uniqueIndex = <span class="number">1</span>; <span class="comment">// 从第二个元素开始检查</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] !== nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            nums[uniqueIndex] = nums[i];</span><br><span class="line">            uniqueIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uniqueIndex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> newLength = <span class="title function_">removeDuplicates</span>(nums);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newLength); <span class="comment">// 输出新的数组长度</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nums.<span class="title function_">slice</span>(<span class="number">0</span>, newLength)); <span class="comment">// 输出新的数组内容</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2、-螺旋矩阵"><a href="#2、-螺旋矩阵" class="headerlink" title="2、[螺旋矩阵]"></a>2、[螺旋矩阵]</h4><p>背代码！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> generateMatrix = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> startX = startY = <span class="number">0</span>;   <span class="comment">// 起始位置</span></span><br><span class="line">    <span class="keyword">let</span> loop = <span class="title class_">Math</span>.<span class="title function_">floor</span>(n/<span class="number">2</span>);   <span class="comment">// 旋转圈数</span></span><br><span class="line">    <span class="keyword">let</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>(n/<span class="number">2</span>);    <span class="comment">// 中间位置</span></span><br><span class="line">    <span class="keyword">let</span> offset = <span class="number">1</span>;    <span class="comment">// 控制每一层填充元素个数</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">1</span>;     <span class="comment">// 更新填充数字</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (loop--) &#123;</span><br><span class="line">        <span class="keyword">let</span> row = startX, col = startY;</span><br><span class="line">        <span class="comment">// 上行从左到右（左闭右开）</span></span><br><span class="line">        <span class="keyword">for</span> (; col &lt; n - offset; col++) &#123;</span><br><span class="line">            res[row][col] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右列从上到下（左闭右开）</span></span><br><span class="line">        <span class="keyword">for</span> (; row &lt; n - offset; row++) &#123;</span><br><span class="line">            res[row][col] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下行从右到左（左闭右开）</span></span><br><span class="line">        <span class="keyword">for</span> (; col &gt; startY; col--) &#123;</span><br><span class="line">            res[row][col] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左列做下到上（左闭右开）</span></span><br><span class="line">        <span class="keyword">for</span> (; row &gt; startX; row--) &#123;</span><br><span class="line">            res[row][col] = count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新起始位置</span></span><br><span class="line">        startX++;</span><br><span class="line">        startY++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新offset</span></span><br><span class="line">        offset += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span></span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        res[mid][mid] = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3、括号区间匹配"><a href="#3、括号区间匹配" class="headerlink" title="3、括号区间匹配"></a>3、括号区间匹配</h4><pre><code>由[]、()组成的字符串，最少插入多少个括号可以实现匹配？输出所需的括号数量。
</code></pre>
<p>就是注意考虑情况，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minInsertionsToMatch = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> leftNeeded = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> rightNeeded = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (char === <span class="string">&#x27;(&#x27;</span> || char === <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            rightNeeded++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (char === <span class="string">&#x27;)&#x27;</span> || char === <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rightNeeded &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                rightNeeded--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                leftNeeded++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> leftNeeded + rightNeeded;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;([)]&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">&quot;(([]&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">minInsertionsToMatch</span>(s1)); <span class="comment">// 输出: 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">minInsertionsToMatch</span>(s2)); <span class="comment">// 输出: 2</span></span><br></pre></td></tr></table></figure>

<h3 id="二、问答题"><a href="#二、问答题" class="headerlink" title="二、问答题"></a>二、问答题</h3><h4 id="1、进程和线程有什么区别？进程间通信方式有哪些？"><a href="#1、进程和线程有什么区别？进程间通信方式有哪些？" class="headerlink" title="1、进程和线程有什么区别？进程间通信方式有哪些？"></a>1、进程和线程有什么区别？进程间通信方式有哪些？</h4><h4 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h4><ul>
<li><strong>进程</strong>：<ul>
<li>是程序的一次执行过程，操作系统进行资源分配和调度执行的基本单位，拥有独立的内存空间。</li>
<li>进程之间的资源是隔离的，进程切换开销较大。</li>
<li>适用于需要并行处理且相互隔离的任务。</li>
</ul>
</li>
<li><strong>线程</strong>：<ul>
<li>是进程中的一个执行单元，程序执行的最小单位。共享进程的内存空间和资源。</li>
<li>线程之间通信方便，但缺乏进程间的隔离性，线程切换开销较小。</li>
<li>适用于需要并发处理且共享数据的任务。</li>
</ul>
</li>
</ul>
<h4 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h4><ul>
<li>**管道 (Pipe)**：用于父子进程间的通信，单向或双向的字节流。</li>
<li>**消息队列 (Message Queue)**：由消息组成的链表，存储在内核中。</li>
<li>**共享内存 (Shared Memory)**：多个进程共享一块内存区域，速度快，但需要同步机制。</li>
<li>**信号 (Signal)**：用于通知进程某个事件的发生。</li>
<li>**套接字 (Socket)**：用于不同主机或同一主机上进程间的网络通信。</li>
<li>**信号量 (Semaphore)**：用于进程间的同步控制。</li>
</ul>
<h4 id="2、列举常用数据结构，各自的特点和使用场景"><a href="#2、列举常用数据结构，各自的特点和使用场景" class="headerlink" title="2、列举常用数据结构，各自的特点和使用场景"></a>2、列举常用数据结构，各自的特点和使用场景</h4><ul>
<li>**数组 (Array)**：连续内存空间，随机访问快，插入和删除慢。适用于需要频繁访问的场景。</li>
<li>**链表 (Linked List)**：非连续内存空间，插入和删除快，随机访问慢。适用于需要频繁插入和删除的场景。</li>
<li>**栈 (Stack)**：后进先出 (LIFO)，适用于递归、表达式求值、语法分析等场景。</li>
<li>**队列 (Queue)**：先进先出 (FIFO)，适用于排队处理、广度优先搜索等场景。</li>
<li>**哈希表 (Hash Table)**：通过哈希函数进行快速查找，适用于需要快速查找和插入的场景。</li>
<li>**树 (Tree)**：层次结构，适用于需要快速查找、插入和删除的场景，如二叉搜索树、平衡树。</li>
<li>**图 (Graph)**：用于表示网络结构，适用于图论算法，如最短路径、最小生成树等。</li>
<li>**堆 (Heap)**：完全二叉树，常用于实现优先队列。</li>
</ul>
<h4 id="3、多线程编程要注意哪些情况？"><a href="#3、多线程编程要注意哪些情况？" class="headerlink" title="3、多线程编程要注意哪些情况？"></a>3、多线程编程要注意哪些情况？</h4><ul>
<li><strong>线程安全</strong>：避免多个线程同时访问共享资源，使用锁或同步机制。</li>
<li><strong>死锁</strong>：多个线程互相等待对方释放资源，导致程序无法继续运行。</li>
<li><strong>资源竞争</strong>：多个线程争夺同一资源，导致数据不一致或程序崩溃。</li>
<li><strong>线程调度</strong>：合理调度线程，避免过多线程导致的上下文切换开销。</li>
<li><strong>内存一致性</strong>：保证线程之间的内存可见性，使用内存屏障或锁机制。</li>
</ul>
<h4 id="4、HTTP请求头包含哪些内容？"><a href="#4、HTTP请求头包含哪些内容？" class="headerlink" title="4、HTTP请求头包含哪些内容？"></a>4、HTTP请求头包含哪些内容？</h4><ul>
<li>**通用头部 (General Headers)**：如 <code>Cache-Control</code>, <code>Connection</code>, <code>Date</code>。</li>
<li>**请求头部 (Request Headers)**：如 <code>Accept</code>, <code>Accept-Encoding</code>, <code>Authorization</code>, <code>Host</code>, <code>User-Agent</code>, <code>Referer</code>。</li>
<li>**响应头部 (Response Headers)**：如 <code>Location</code>, <code>Server</code>, <code>Set-Cookie</code>, <code>Content-Type</code>。</li>
<li>**实体头部 (Entity Headers)**：如 <code>Content-Length</code>, <code>Content-Encoding</code>, <code>Content-Language</code>, <code>Content-Location</code>, <code>Content-MD5</code>, <code>Last-Modified</code>。</li>
</ul>
<h4 id="5、TCP和HTTP的具体区别？"><a href="#5、TCP和HTTP的具体区别？" class="headerlink" title="5、TCP和HTTP的具体区别？"></a>5、TCP和HTTP的具体区别？</h4><ul>
<li><p>**TCP (Transmission Control Protocol)**：</p>
<ul>
<li>是传输层协议，提供可靠的、面向连接的通信。</li>
<li>确保数据包按序到达，进行错误检查和流量控制。</li>
<li>用于底层数据传输，如 HTTP 协议的数据传输。</li>
</ul>
</li>
<li><p>**HTTP (HyperText Transfer Protocol)**：</p>
<ul>
<li>是应用层协议，基于 TCP 协议。</li>
<li>无状态协议，每个请求&#x2F;响应都是独立的。</li>
<li>用于在客户端和服务器之间传输超文本（如 HTML 文档、图片、视频）。</li>
</ul>
</li>
</ul>
<h4 id="6、怎么提升在线视频的播放秒开率？"><a href="#6、怎么提升在线视频的播放秒开率？" class="headerlink" title="6、怎么提升在线视频的播放秒开率？"></a>6、怎么提升在线视频的播放秒开率？</h4><ul>
<li><strong>优化缓冲策略</strong>：减少初始缓冲时间，根据网络情况调整缓冲区大小。</li>
<li><strong>预加载技术</strong>：在用户点击播放前预加载部分视频内容。</li>
<li><strong>分段加载</strong>：将视频分成多个小段，先加载前几段。</li>
<li>**使用内容分发网络 (CDN)**：将视频内容分发到离用户最近的服务器，减少传输延迟。</li>
<li><strong>压缩视频</strong>：使用更高效的视频编码格式，减少视频文件大小。</li>
<li><strong>网络协议优化</strong>：使用更高效的传输协议，如 HTTP&#x2F;2 或 QUIC。</li>
<li><strong>客户端优化</strong>：优化播放器的解码和渲染性能。</li>
</ul>
<h1 id="2024-06-06用友提前批模拟笔试"><a href="#2024-06-06用友提前批模拟笔试" class="headerlink" title="2024-06-06用友提前批模拟笔试"></a>2024-06-06用友提前批模拟笔试</h1><p>1、大数减法：以字符串的形式读入两个数字，编写一个函数计算它们的差，以字符串形式返回。</p>
<h6 id="输入示例"><a href="#输入示例" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2</span><br></pre></td></tr></table></figure>
<h6 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure>

<p>解法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">subtractStrings</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    <span class="comment">// 确定结果的符号</span></span><br><span class="line">    <span class="keyword">let</span> isNegative = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (num1 === num2) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (num1.<span class="property">length</span> &lt; num2.<span class="property">length</span> || (num1.<span class="property">length</span> === num2.<span class="property">length</span> &amp;&amp; num1 &lt; num2)) &#123;</span><br><span class="line">        [num1, num2] = [num2, num1];</span><br><span class="line">        isNegative = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 补齐 num2 前导零</span></span><br><span class="line">    num2 = num2.<span class="title function_">padStart</span>(num1.<span class="property">length</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> borrow = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = num1.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">let</span> digit1 = <span class="built_in">parseInt</span>(num1[i], <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">let</span> digit2 = <span class="built_in">parseInt</span>(num2[i], <span class="number">10</span>) + borrow;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (digit1 &lt; digit2) &#123;</span><br><span class="line">            digit1 += <span class="number">10</span>;</span><br><span class="line">            borrow = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            borrow = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result.<span class="title function_">push</span>(digit1 - digit2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除结果中的前导零</span></span><br><span class="line">    <span class="keyword">while</span> (result[result.<span class="property">length</span> - <span class="number">1</span>] === <span class="number">0</span>) &#123;</span><br><span class="line">        result.<span class="title function_">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理负号</span></span><br><span class="line">    <span class="keyword">if</span> (isNegative) &#123;</span><br><span class="line">        result.<span class="title function_">push</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取输入</span></span><br><span class="line"><span class="keyword">const</span> readline = <span class="built_in">require</span>(<span class="string">&#x27;readline&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rl = readline.<span class="title function_">createInterface</span>(&#123;</span><br><span class="line">    <span class="attr">input</span>: process.<span class="property">stdin</span>,</span><br><span class="line">    <span class="attr">output</span>: process.<span class="property">stdout</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rl.<span class="title function_">on</span>(<span class="string">&#x27;line&#x27;</span>, <span class="function">(<span class="params">input</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [num1, num2] = input.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">subtractStrings</span>(num1, num2));</span><br><span class="line">    rl.<span class="title function_">close</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>2、滑动窗口最大值<br>给定一个整数数组 nums 和一个整数 k，k 表示滑动窗口的大小。你需要找出每个滑动窗口中的最大值与最小值的差，并返回这些差的最大值。</p>
<h6 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h6><p>数组的长度为 n，1 &lt;&#x3D; n &lt;&#x3D; 10000，数组中的每个元素范围为[-10000,10000]，滑动窗口大小k的范围为[1,n]。</p>
<h6 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h6><p>例如，给你nums &#x3D; [1,3,-1,-3,5,3,6,7]和 k &#x3D; 3，每个窗口中的最大值与最小值的差分别为[2,4,6,8]，所以返回 8。</p>
<h6 id="输入示例-1"><a href="#输入示例-1" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br></pre></td></tr></table></figure>
<h6 id="输出示例-1"><a href="#输出示例-1" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>



<p>3、软件构建<br>某个大型软件项目的构建系统拥有 N 个文件，文件编号从 0 到 N - 1，在这些文件中，某些文件依赖于其他文件的内容，这意味着如果文件 A 依赖于文件 B，则必须在处理文件 A 之前处理文件 B （0 &lt;&#x3D; A, B &lt;&#x3D; N - 1）。请编写一个算法，用于确定文件处理的顺序。</p>
<h6 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行输入两个正整数 N, M。表示 N 个文件之间拥有 M 条依赖关系。后续 M 行，每行两个正整数 S 和 T，表示 T 文件依赖于 S 文件。</p>
<h6 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出共一行，如果能处理成功，则输出文件顺序，用空格隔开。 <br>如果不能成功处理（相互依赖），则输出 -1。</p>
<h6 id="输入示例-2"><a href="#输入示例-2" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 4</span><br><span class="line">0 1</span><br><span class="line">0 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure>
<h6 id="输出示例-2"><a href="#输出示例-2" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 1 2 3 4</span><br></pre></td></tr></table></figure>


<h1 id="123"><a href="#123" class="headerlink" title="123"></a>123</h1>]]></content>
      <categories>
        <category>笔面记录</category>
      </categories>
      <tags>
        <tag>笔试题</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题目记录</title>
    <url>//%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%89%B9%E6%AE%8A%E8%AE%B0%E5%BD%95/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>2024-06-06深圳学而思小高科学素养秋招提前批<br>试讲10min+聊天20min<br>![[Pasted image 20240607110710.png]]</p>
]]></content>
      <categories>
        <category>笔面记录</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>好玩代码收集</title>
    <url>//%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%89%B9%E6%AE%8A%E8%AE%B0%E5%BD%95/%E5%A5%BD%E7%8E%A9%E4%BB%A3%E7%A0%81%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<h1 id="JS身份证格式校验"><a href="#JS身份证格式校验" class="headerlink" title="JS身份证格式校验"></a>JS身份证格式校验</h1><p>[<a href="https://mp.weixin.qq.com/s/V0Fquj_Dy6OpqbwqMHUg6Q]">https://mp.weixin.qq.com/s/V0Fquj_Dy6OpqbwqMHUg6Q]</a></p>
<h1 id="检测并显示密码强度"><a href="#检测并显示密码强度" class="headerlink" title="检测并显示密码强度"></a>检测并显示密码强度</h1><p>[<a href="https://mp.weixin.qq.com/s/DCS4RKrXuPFj8sOoMzVY-g]">https://mp.weixin.qq.com/s/DCS4RKrXuPFj8sOoMzVY-g]</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>代码收集</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>//Obsidian%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h1 id="双链"><a href="#双链" class="headerlink" title="双链"></a>双链</h1><p>用[[]]可以链接到别的笔记，加井号选择段落，再加^选择每一段内容，自己在要连接的文章里打上^可以自己做标记。<br>加 | 改别名，前面加 ！可以展开被引用的内容。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>//%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
